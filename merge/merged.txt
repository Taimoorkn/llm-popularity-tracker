// File: c:\Users\Taimoor\Documents\GitHub\llm-popularity-tracker\app\api\health\route.js
import { NextResponse } from 'next/server';
import { getAdaptedVoteManager } from '@/lib/vote-manager-wrapper';
import dbManager from '@/lib/database';
import cacheManager from '@/lib/cache';
import logger from '@/lib/logger';
import { securityHeaders } from '@/lib/middleware';

export async function GET(request) {
  const startTime = Date.now();
  
  try {
    const voteManager = await getAdaptedVoteManager();
    const health = await voteManager.checkHealth();
    
    // Additional health checks
    const checks = {
      database: health.database,
      cache: health.cache,
      api: {
        status: 'healthy',
        latency: `${Date.now() - startTime}ms`
      },
      overall: health.status
    };
    
    // Determine HTTP status based on health
    const httpStatus = health.status === 'healthy' ? 200 : 
                       health.status === 'degraded' ? 503 : 500;
    
    logger.debug('Health check performed', checks);
    
    return NextResponse.json(
      {
        status: health.status,
        checks,
        timestamp: new Date().toISOString(),
        uptime: process.uptime(),
        memory: process.memoryUsage(),
        version: process.env.npm_package_version || '0.1.0'
      },
      {
        status: httpStatus,
        headers: securityHeaders()
      }
    );
  } catch (error) {
    logger.error('Health check failed:', error);
    
    return NextResponse.json(
      {
        status: 'unhealthy',
        error: error.message,
        timestamp: new Date().toISOString()
      },
      {
        status: 500,
        headers: securityHeaders()
      }
    );
  }
}

// File: c:\Users\Taimoor\Documents\GitHub\llm-popularity-tracker\app\api\stats\route.js
import { NextResponse } from 'next/server';
import { getAdaptedVoteManager } from '@/lib/vote-manager-wrapper';
import { apiMiddleware, securityHeaders } from '@/lib/middleware';
import logger from '@/lib/logger';

export async function GET(request) {
  // Apply middleware
  const middlewareResult = await apiMiddleware(request, {
    rateLimit: {
      maxRequests: 200,
      windowMs: 60000 // 200 requests per minute
    }
  });
  
  if (middlewareResult.status) {
    return middlewareResult;
  }
  
  const { requestInfo, rateLimitHeaders } = middlewareResult;
  
  try {
    const voteManager = await getAdaptedVoteManager();
    const stats = await voteManager.getStats();
    const rankings = await voteManager.getRankings();
    
    logger.logResponse(requestInfo, { status: 200 });
    
    return NextResponse.json(
      {
        stats,
        rankings,
        timestamp: new Date().toISOString(),
      },
      {
        headers: { ...securityHeaders(), ...rateLimitHeaders }
      }
    );
  } catch (error) {
    logger.error('Stats error:', error);
    logger.logResponse(requestInfo, { status: 500 }, error);
    
    return NextResponse.json(
      { error: 'Failed to get stats' },
      { 
        status: 500,
        headers: { ...securityHeaders(), ...rateLimitHeaders }
      }
    );
  }
}

// File: c:\Users\Taimoor\Documents\GitHub\llm-popularity-tracker\app\api\vote\route.js
import { NextResponse } from 'next/server';
import { getAdaptedVoteManager } from '@/lib/vote-manager-wrapper';
import { apiMiddleware, schemas, detectFraud, securityHeaders } from '@/lib/middleware';
import logger from '@/lib/logger';

export async function POST(request) {
  // Apply middleware
  const middlewareResult = await apiMiddleware(request, {
    schema: schemas.vote,
    rateLimit: {
      maxRequests: 60,
      windowMs: 60000 // 60 requests per minute
    }
  });
  
  if (middlewareResult.status) {
    // Middleware returned an error response
    return middlewareResult;
  }
  
  const { validatedData, requestInfo, rateLimitHeaders } = middlewareResult;
  
  try {
    const { fingerprint, llmId, voteType } = validatedData;
    
    // Fraud detection
    const fraudCheck = await detectFraud(fingerprint, 'vote', {
      llmId,
      voteType
    });
    
    if (fraudCheck.isSuspicious && fraudCheck.riskScore > 50) {
      logger.business.fraudulentVoteDetected(
        fingerprint,
        'High risk score',
        fraudCheck
      );
      
      return NextResponse.json(
        { error: 'Suspicious activity detected. Please try again later.' },
        { status: 429 }
      );
    }
    
    // Process vote using database
    const voteManager = await getAdaptedVoteManager();
    const result = await voteManager.vote(fingerprint, llmId, voteType, {
      ip: requestInfo.ip,
      userAgent: requestInfo.userAgent
    });
    
    if (!result.success) {
      return NextResponse.json(
        { error: result.error },
        { status: 400, headers: { ...securityHeaders(), ...rateLimitHeaders } }
      );
    }
    
    // Log successful vote
    logger.logResponse(requestInfo, { status: 200 });
    
    return NextResponse.json(
      {
        success: true,
        votes: result.votes,
        userVote: result.userVote,
        previousVote: result.previousVote,
      },
      { 
        status: 200,
        headers: { ...securityHeaders(), ...rateLimitHeaders }
      }
    );
  } catch (error) {
    logger.error('Vote error:', error);
    logger.logResponse(requestInfo, { status: 500 }, error);
    
    return NextResponse.json(
      { error: 'Failed to process vote' },
      { 
        status: 500,
        headers: { ...securityHeaders(), ...rateLimitHeaders }
      }
    );
  }
}

// This endpoint is deprecated - use POST /api/vote/sync instead
export async function GET(request) {
  // Apply middleware
  const middlewareResult = await apiMiddleware(request, {
    rateLimit: {
      maxRequests: 100,
      windowMs: 60000 // 100 requests per minute
    }
  });
  
  if (middlewareResult.status) {
    return middlewareResult;
  }
  
  const { requestInfo, rateLimitHeaders } = middlewareResult;
  
  try {
    const voteManager = await getAdaptedVoteManager();
    const votes = await voteManager.getVotes();
    const rankings = await voteManager.getRankings();
    const stats = await voteManager.getStats();
    
    logger.logResponse(requestInfo, { status: 200 });
    
    return NextResponse.json(
      {
        votes,
        rankings,
        stats,
        userVotes: {},
      },
      {
        headers: { ...securityHeaders(), ...rateLimitHeaders }
      }
    );
  } catch (error) {
    logger.error('Get votes error:', error);
    logger.logResponse(requestInfo, { status: 500 }, error);
    
    return NextResponse.json(
      { error: 'Failed to get votes' },
      { 
        status: 500,
        headers: { ...securityHeaders(), ...rateLimitHeaders }
      }
    );
  }
}

// File: c:\Users\Taimoor\Documents\GitHub\llm-popularity-tracker\app\api\vote\sync\route.js
import { NextResponse } from 'next/server';
import { getAdaptedVoteManager } from '@/lib/vote-manager-wrapper';
import { apiMiddleware, schemas, securityHeaders } from '@/lib/middleware';
import logger from '@/lib/logger';

export async function POST(request) {
  // Apply middleware
  const middlewareResult = await apiMiddleware(request, {
    schema: schemas.sync,
    rateLimit: {
      maxRequests: 100,
      windowMs: 60000 // 100 requests per minute
    }
  });
  
  if (middlewareResult.status) {
    return middlewareResult;
  }
  
  const { validatedData, requestInfo, rateLimitHeaders } = middlewareResult;
  
  try {
    const { fingerprint } = validatedData;
    
    const voteManager = await getAdaptedVoteManager();
    const syncData = await voteManager.syncUserVotes(fingerprint);
    
    logger.logResponse(requestInfo, { status: 200 });
    
    return NextResponse.json(
      syncData,
      {
        headers: { ...securityHeaders(), ...rateLimitHeaders }
      }
    );
  } catch (error) {
    logger.error('Sync votes error:', error);
    logger.logResponse(requestInfo, { status: 500 }, error);
    
    return NextResponse.json(
      { error: 'Failed to sync votes' },
      { 
        status: 500,
        headers: { ...securityHeaders(), ...rateLimitHeaders }
      }
    );
  }
}

// File: c:\Users\Taimoor\Documents\GitHub\llm-popularity-tracker\app\globals.css
@tailwind base;
@tailwind components;
@tailwind utilities;

@layer base {
  :root {
    --background: #0a0a0a;
    --foreground: #ededed;
  }

  body {
    @apply bg-background text-foreground;
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
  }

  * {
    @apply border-border;
  }
}

@layer utilities {
  .text-gradient {
    @apply bg-gradient-to-r from-primary via-accent to-success bg-clip-text text-transparent;
  }

  .glow {
    @apply shadow-lg shadow-primary/20;
  }

  .card-glow {
    @apply hover:shadow-xl hover:shadow-primary/10 transition-shadow duration-300;
  }

  .scrollbar-thin {
    scrollbar-width: thin;
    scrollbar-color: #4b5563 #1f2937;
  }

  .scrollbar-thin::-webkit-scrollbar {
    width: 8px;
    height: 8px;
  }

  .scrollbar-thin::-webkit-scrollbar-track {
    @apply bg-gray-800 rounded-full;
  }

  .scrollbar-thin::-webkit-scrollbar-thumb {
    @apply bg-gray-600 rounded-full hover:bg-gray-500;
  }
}

// File: c:\Users\Taimoor\Documents\GitHub\llm-popularity-tracker\app\layout.js
import { Geist, Geist_Mono } from "next/font/google";
import "./globals.css";

const geistSans = Geist({
  variable: "--font-geist-sans",
  subsets: ["latin"],
});

const geistMono = Geist_Mono({
  variable: "--font-geist-mono",
  subsets: ["latin"],
});

export const metadata = {
  title: "LLM Popularity Tracker 2025",
  description: "Vote for your favorite Large Language Models and see real-time community rankings",
};

export default function RootLayout({ children }) {
  return (
    <html lang="en" className="dark">
      <body
        className={`${geistSans.variable} ${geistMono.variable} antialiased bg-background text-foreground`}
      >
        {children}
      </body>
    </html>
  );
}


// File: c:\Users\Taimoor\Documents\GitHub\llm-popularity-tracker\app\page.js
'use client';

import { useEffect, useState } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { Search, Filter, TrendingUp } from 'lucide-react';
import { Toaster } from 'sonner';
import Header from '@/components/Header';
import LLMCard from '@/components/LLMCard';
import StatsPanel from '@/components/StatsPanel';
import VoteChart from '@/components/VoteChart';
import useVoteStore from '@/store/useVoteStore';

export default function Home() {
  const [searchTerm, setSearchTerm] = useState('');
  const [sortBy, setSortBy] = useState('name'); // votes, name, company
  const [showChart, setShowChart] = useState(true);
  
  const { llms, initializeVotes, rankings, loading } = useVoteStore();
  
  useEffect(() => {
    initializeVotes();
    // Removed automatic polling - only update on page load/refresh
  }, [initializeVotes]);
  
  // Filter LLMs but maintain stable ordering
  const filteredLLMs = llms
    .filter(llm => 
      llm.name.toLowerCase().includes(searchTerm.toLowerCase()) ||
      llm.company.toLowerCase().includes(searchTerm.toLowerCase()) ||
      llm.description.toLowerCase().includes(searchTerm.toLowerCase())
    );
  
  // Create stable sorted order that doesn't change based on vote changes
  const stableSortedLLMs = [...filteredLLMs].sort((a, b) => {
    if (sortBy === 'name') {
      return a.name.localeCompare(b.name);
    } else if (sortBy === 'company') {
      return a.company.localeCompare(b.company);
    } else if (sortBy === 'votes') {
      // Use initial vote counts from data, not dynamic rankings
      const aInitialRank = llms.findIndex(llm => llm.id === a.id);
      const bInitialRank = llms.findIndex(llm => llm.id === b.id);
      return aInitialRank - bInitialRank;
    }
    return 0;
  });
  
  return (
    <div className="min-h-screen bg-background">
      <Toaster position="bottom-right" theme="dark" />
      <Header />
      
      <main className="container mx-auto px-4 py-8">
        {/* Hero Section */}
        <motion.div
          initial={{ opacity: 0, y: 20 }}
          animate={{ opacity: 1, y: 0 }}
          className="text-center mb-8"
        >
          <h2 className="text-3xl md:text-4xl font-bold text-foreground mb-4">
            Which LLM Rules in 2025?
          </h2>
          <p className="text-muted-foreground max-w-2xl mx-auto">
            Cast your vote for the AI models you love. Upvote your favorites, downvote the ones you don't prefer.
            Every vote counts in determining the community's choice!
          </p>
        </motion.div>
        
        {/* Stats Panel */}
        <StatsPanel />
        
        {/* Controls */}
        <div className="flex flex-col md:flex-row gap-4 mb-8">
          <div className="flex-1 relative">
            <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 text-muted-foreground" size={20} />
            <input
              type="text"
              placeholder="Search LLMs..."
              value={searchTerm}
              onChange={(e) => setSearchTerm(e.target.value)}
              className="w-full pl-10 pr-4 py-2 bg-card border border-border rounded-lg text-foreground placeholder-muted-foreground focus:outline-none focus:border-primary transition-colors"
            />
          </div>
          
          <div className="flex gap-2">
            <select
              value={sortBy}
              onChange={(e) => setSortBy(e.target.value)}
              className="px-4 py-2 bg-card border border-border rounded-lg text-foreground focus:outline-none focus:border-primary transition-colors"
            >
              <option value="votes">Sort by Votes</option>
              <option value="name">Sort by Name</option>
              <option value="company">Sort by Company</option>
            </select>
            
            
          </div>
        </div>
        
        {/* Chart - Always visible */}
        <div className="mb-8">
          <VoteChart />
        </div>
        
        {/* LLM Grid/List */}
        {loading ? (
          <div className="flex items-center justify-center h-64">
            <motion.div
              animate={{ rotate: 360 }}
              transition={{ duration: 1, repeat: Infinity, ease: "linear" }}
              className="w-8 h-8 border-4 border-primary border-t-transparent rounded-full"
            />
          </div>
        ) : (
          <motion.div
            layout
            className="grid gap-4 grid-cols-2 md:grid-cols-3 lg:grid-cols-4 xl:grid-cols-5"
          >
            {stableSortedLLMs.map((llm, index) => (
              <LLMCard key={llm.id} llm={llm} index={index} />
            ))}
          </motion.div>
        )}
        
        {stableSortedLLMs.length === 0 && !loading && (
          <motion.div
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            className="text-center py-16"
          >
            <p className="text-muted-foreground text-lg">
              No LLMs found matching your search.
            </p>
          </motion.div>
        )}
      </main>
      
      {/* Footer */}
      <footer className="border-t border-border mt-16 py-8">
        <div className="container mx-auto px-4 text-center">
          <p className="text-muted-foreground text-sm">
            Made with ❤️ by the AI Community | 2025
          </p>
          <p className="text-xs text-muted-foreground mt-2">
            Vote responsibly. Each user can upvote or downvote any model.
          </p>
        </div>
      </footer>
    </div>
  );
}

// File: c:\Users\Taimoor\Documents\GitHub\llm-popularity-tracker\components\Header.jsx
'use client';

import { motion } from 'framer-motion';
import { Sparkles, Github } from 'lucide-react';

export default function Header() {
  return (
    <motion.header
      initial={{ opacity: 0, y: -20 }}
      animate={{ opacity: 1, y: 0 }}
      className="border-b border-border bg-card/50 backdrop-blur-sm sticky top-0 z-50"
    >
      <div className="container mx-auto px-4 py-4">
        <div className="flex items-center justify-between">
          <div className="flex items-center gap-3">
            <motion.div
              animate={{ rotate: 360 }}
              transition={{ duration: 20, repeat: Infinity, ease: "linear" }}
            >
              <Sparkles size={32} className="text-primary" />
            </motion.div>
            <div>
              <h1 className="text-2xl font-bold text-gradient">LLM Popularity Tracker</h1>
              <p className="text-xs text-muted-foreground">Vote for your favorite AI models</p>
            </div>
          </div>
          
          <div className="flex items-center gap-4">
            <motion.div
              whileHover={{ scale: 1.05 }}
              whileTap={{ scale: 0.95 }}
              className="text-sm bg-primary/10 text-primary px-4 py-2 rounded-full font-medium"
            >
              2025 Edition
            </motion.div>
            <motion.a
              href="https://github.com"
              target="_blank"
              rel="noopener noreferrer"
              whileHover={{ scale: 1.1 }}
              whileTap={{ scale: 0.9 }}
              className="text-muted-foreground hover:text-foreground transition-colors"
            >
              <Github size={20} />
            </motion.a>
          </div>
        </div>
      </div>
    </motion.header>
  );
}

// File: c:\Users\Taimoor\Documents\GitHub\llm-popularity-tracker\components\LLMCard.jsx
'use client';

import { useState } from 'react';
import { motion } from 'framer-motion';
import { ChevronUp, ChevronDown, TrendingUp } from 'lucide-react';
import useVoteStore from '@/store/useVoteStore';
import { toast } from 'sonner';

export default function LLMCard({ llm, index }) {
  const [imageError, setImageError] = useState(false);
  const { vote, getUserVote, getVoteCount, isTrending, getRank } = useVoteStore();
  
  const userVote = getUserVote(llm.id);
  const voteCount = getVoteCount(llm.id);
  const trending = isTrending(llm.id);
  const rank = getRank(llm.id);
  
  const handleVote = async (voteType) => {
    if (userVote === voteType) {
      // Remove vote if clicking the same button
      await vote(llm.id, 0);
      toast.success('Vote removed');
    } else {
      await vote(llm.id, voteType);
      toast.success(voteType === 1 ? 'Upvoted!' : 'Downvoted!');
    }
  };
  
  return (
    <motion.div
      initial={{ opacity: 0, y: 20 }}
      animate={{ opacity: 1, y: 0 }}
      transition={{ delay: index * 0.05 }}
      whileHover={{ scale: 1.02 }}
      className="relative bg-gradient-to-br from-card to-card/80 border border-border/50 rounded-xl p-5 shadow-lg hover:shadow-xl transition-all duration-300 backdrop-blur-sm"
    >
      {/* Rank Badge */}
      {rank && rank <= 5 && (
        <div className={`absolute -top-2 -right-2 w-7 h-7 rounded-full flex items-center justify-center text-xs font-bold shadow-lg
          ${rank === 1 ? 'bg-gradient-to-r from-yellow-400 to-yellow-500 text-black' : ''}
          ${rank === 2 ? 'bg-gradient-to-r from-gray-300 to-gray-400 text-black' : ''}
          ${rank === 3 ? 'bg-gradient-to-r from-orange-400 to-orange-600 text-white' : ''}
          ${rank === 4 ? 'bg-gradient-to-r from-blue-400 to-blue-500 text-white' : ''}
          ${rank === 5 ? 'bg-gradient-to-r from-green-400 to-green-500 text-white' : ''}
        `}>
          #{rank}
        </div>
      )}
      
      {/* Trending Badge */}
      {trending && (
        <motion.div
          initial={{ scale: 0, rotate: -10 }}
          animate={{ scale: 1, rotate: 0 }}
          className="absolute top-2 left-2 bg-gradient-to-r from-red-500 to-pink-500 text-white px-2 py-1 rounded-full text-xs font-bold flex items-center gap-1 shadow-md"
        >
          <TrendingUp size={10} />
          HOT
        </motion.div>
      )}
      
      {/* Header with Logo and Info */}
      <div className="flex items-start gap-4 mb-5">
        <div className="flex-shrink-0 w-12 h-12 rounded-lg overflow-hidden bg-white/10 backdrop-blur-sm border border-white/20 flex items-center justify-center">
          {llm.image && !imageError ? (
            <img 
              src={llm.image} 
              alt={`${llm.company} logo`}
              className="w-10 h-10 object-contain"
              onError={() => setImageError(true)}
            />
          ) : (
            <span className="text-xl">{llm.logo}</span>
          )}
        </div>
        <div className="flex-1 min-w-0">
          <h3 className="text-lg font-bold text-foreground truncate">{llm.name}</h3>
          <p className="text-sm text-muted-foreground/80 font-medium">{llm.company}</p>
          <p className="text-xs text-muted-foreground/60 mt-1">{llm.releaseYear}</p>
        </div>
      </div>
      
      {/* Vote Section */}
      <div className="flex items-center justify-between bg-black/20 backdrop-blur-sm rounded-lg p-3">
        <motion.button
          whileTap={{ scale: 0.95 }}
          whileHover={{ scale: 1.05 }}
          onClick={() => handleVote(1)}
          className={`flex items-center justify-center w-10 h-10 rounded-lg transition-all shadow-md ${
            userVote === 1
              ? 'bg-gradient-to-r from-green-500 to-emerald-500 text-white shadow-green-500/30'
              : 'bg-white/10 hover:bg-green-500/20 text-green-400 hover:text-green-300 border border-green-400/30'
          }`}
          aria-label="Upvote"
        >
          <ChevronUp size={20} strokeWidth={2.5} />
        </motion.button>
        
        <div className="flex flex-col items-center px-4">
          <span className={`text-xl font-bold ${
            voteCount > 0 ? 'text-green-400' : voteCount < 0 ? 'text-red-400' : 'text-gray-400'
          }`}>
            {voteCount > 0 ? '+' : ''}{voteCount}
          </span>
          <span className="text-xs text-muted-foreground/60">votes</span>
        </div>
        
        <motion.button
          whileTap={{ scale: 0.95 }}
          whileHover={{ scale: 1.05 }}
          onClick={() => handleVote(-1)}
          className={`flex items-center justify-center w-10 h-10 rounded-lg transition-all shadow-md ${
            userVote === -1
              ? 'bg-gradient-to-r from-red-500 to-rose-500 text-white shadow-red-500/30'
              : 'bg-white/10 hover:bg-red-500/20 text-red-400 hover:text-red-300 border border-red-400/30'
          }`}
          aria-label="Downvote"
        >
          <ChevronDown size={20} strokeWidth={2.5} />
        </motion.button>
      </div>
    </motion.div>
  );
}

// File: c:\Users\Taimoor\Documents\GitHub\llm-popularity-tracker\components\StatsPanel.jsx
'use client';

import { motion } from 'framer-motion';
import { TrendingUp, Users, Clock, Trophy, Activity } from 'lucide-react';
import useVoteStore from '@/store/useVoteStore';

export default function StatsPanel() {
  const { stats } = useVoteStore();
  
  const statCards = [
    {
      icon: Users,
      label: 'Total Votes',
      value: stats.totalVotes || 0,
      color: 'text-primary',
      bgColor: 'bg-primary/10',
    },
    {
      icon: Activity,
      label: 'Votes Today',
      value: stats.votesToday || 0,
      color: 'text-success',
      bgColor: 'bg-success/10',
    },
    {
      icon: Clock,
      label: 'Last Hour',
      value: stats.votesLastHour || 0,
      color: 'text-accent',
      bgColor: 'bg-accent/10',
    },
    {
      icon: Trophy,
      label: 'Leading',
      value: stats.topModel || 'None',
      color: 'text-yellow-500',
      bgColor: 'bg-yellow-500/10',
      small: true,
    },
  ];
  
  return (
    <div className="grid grid-cols-2 md:grid-cols-4 gap-4 mb-8">
      {statCards.map((stat, index) => (
        <motion.div
          key={stat.label}
          initial={{ opacity: 0, scale: 0.9 }}
          animate={{ opacity: 1, scale: 1 }}
          transition={{ delay: index * 0.1 }}
          className="bg-card border border-border rounded-lg p-4"
        >
          <div className="flex items-center justify-between mb-2">
            <div className={`p-2 rounded-lg ${stat.bgColor}`}>
              <stat.icon size={20} className={stat.color} />
            </div>
            {stat.label === 'Last Hour' && stats.votesLastHour > 0 && (
              <TrendingUp size={16} className="text-success" />
            )}
          </div>
          <p className="text-xs text-muted-foreground mb-1">{stat.label}</p>
          <p className={`${stat.small ? 'text-lg' : 'text-2xl'} font-bold text-foreground`}>
            {typeof stat.value === 'number' ? stat.value.toLocaleString() : stat.value}
          </p>
        </motion.div>
      ))}
    </div>
  );
}

// File: c:\Users\Taimoor\Documents\GitHub\llm-popularity-tracker\components\VoteChart.jsx
'use client';

import { useEffect, useState } from 'react';
import { motion } from 'framer-motion';
import {
  BarChart,
  Bar,
  XAxis,
  YAxis,
  CartesianGrid,
  Tooltip,
  ResponsiveContainer,
  Cell,
} from 'recharts';
import useVoteStore from '@/store/useVoteStore';
import { BarChart3, PieChart } from 'lucide-react';

export default function VoteChart() {
  const [chartType, setChartType] = useState('bar');
  const { votes, llms } = useVoteStore();
  
  // Prepare chart data - show ALL LLMs with their vote counts
  const chartData = llms.map((llm) => {
    const voteCount = votes[llm.id] || 0;
    return {
      name: llm.name,
      votes: voteCount,
      color: llm.color || 'from-gray-500 to-gray-600',
      id: llm.id,
    };
  }).sort((a, b) => b.votes - a.votes); // Sort by votes descending
  
  // Extract gradient colors for bars
  const getBarColor = (color) => {
    const colors = color.match(/from-(\w+)-\d+\sto-(\w+)-\d+/);
    if (colors) {
      const colorMap = {
        green: '#10b981',
        emerald: '#10b981',
        orange: '#f59e0b',
        amber: '#f59e0b',
        blue: '#3b82f6',
        cyan: '#06b6d4',
        purple: '#8b5cf6',
        violet: '#8b5cf6',
        red: '#ef4444',
        pink: '#ec4899',
        indigo: '#6366f1',
        gray: '#6b7280',
        slate: '#64748b',
        teal: '#14b8a6',
        yellow: '#eab308',
      };
      return colorMap[colors[1]] || '#6b7280';
    }
    return '#6b7280';
  };
  
  const CustomTooltip = ({ active, payload }) => {
    if (active && payload && payload[0]) {
      return (
        <div className="bg-card border border-border rounded-lg p-3 shadow-lg">
          <p className="font-bold text-foreground">{payload[0].payload.name}</p>
          <p className="text-sm text-muted-foreground">
            Votes: <span className="text-primary font-bold">{payload[0].value}</span>
          </p>
        </div>
      );
    }
    return null;
  };
  
  return (
    <motion.div
      initial={{ opacity: 0, y: 20 }}
      animate={{ opacity: 1, y: 0 }}
      className="bg-card border border-border rounded-lg p-6"
    >
      <div className="flex items-center justify-between mb-6">
        <h2 className="text-xl font-bold text-foreground flex items-center gap-2">
          <BarChart3 size={24} className="text-primary" />
          All LLM Votes
        </h2>
        <div className="flex gap-2">
          <button
            onClick={() => setChartType('bar')}
            className={`p-2 rounded-lg transition-all ${
              chartType === 'bar' ? 'bg-primary text-white' : 'bg-card-hover text-muted-foreground'
            }`}
          >
            <BarChart3 size={16} />
          </button>
        </div>
      </div>
      
      <ResponsiveContainer width="100%" height={500}>
        <BarChart data={chartData} margin={{ top: 20, right: 30, left: 20, bottom: 100 }}>
          <CartesianGrid strokeDasharray="3 3" stroke="#27272a" />
          <XAxis
            dataKey="name"
            angle={-45}
            textAnchor="end"
            height={120}
            tick={{ fill: '#9ca3af', fontSize: 10 }}
            stroke="#27272a"
            interval={0}
          />
          <YAxis
            tick={{ fill: '#9ca3af' }}
            stroke="#27272a"
            domain={['dataMin - 1', 'dataMax + 1']}
          />
          <Tooltip content={<CustomTooltip />} />
          <Bar dataKey="votes" radius={[4, 4, 0, 0]}>
            {chartData.map((entry, index) => (
              <Cell key={`cell-${index}`} fill={getBarColor(entry.color)} />
            ))}
          </Bar>
        </BarChart>
      </ResponsiveContainer>
    </motion.div>
  );
}

// File: c:\Users\Taimoor\Documents\GitHub\llm-popularity-tracker\data\votes.json
{
  "votes": {
    "gpt-4o": 1,
    "claude-3-5-sonnet": 1,
    "gemini-ultra": -1,
    "llama-3-70b": -1,
    "mistral-large": -1,
    "command-r-plus": 1,
    "grok": 1,
    "perplexity": -1,
    "qwen-2-5": -1,
    "deepseek-coder": 1,
    "phi-3": -1,
    "falcon-180b": -1,
    "vicuna-33b": -1,
    "solar-10-7b": -1,
    "yi-34b": -1,
    "mixtral-8x7b": -1,
    "bard": -1,
    "ernie-4": 1,
    "stablelm-2": -1,
    "inflection-2-5": -1
  },
  "userSessions": {
    "89f160926a37777b575ad591196385dd": {
      "claude-3-5-sonnet": 1,
      "gemini-ultra": -1,
      "llama-3-70b": -1,
      "mistral-large": -1,
      "grok": 1,
      "perplexity": -1,
      "qwen-2-5": -1,
      "deepseek-coder": 1,
      "phi-3": -1,
      "falcon-180b": -1,
      "vicuna-33b": -1,
      "solar-10-7b": -1,
      "yi-34b": -1,
      "mixtral-8x7b": -1,
      "bard": -1,
      "ernie-4": 1,
      "stablelm-2": -1,
      "inflection-2-5": -1,
      "command-r-plus": 1,
      "gpt-4o": 1
    }
  },
  "stats": {
    "totalVotes": 39,
    "lastHourVotes": [
      {
        "llmId": "gpt-4o",
        "voteType": 1,
        "timestamp": "2025-08-26T23:50:17.390Z"
      },
      {
        "llmId": "gpt-4o",
        "voteType": 0,
        "timestamp": "2025-08-26T23:50:18.430Z"
      },
      {
        "llmId": "gpt-4o",
        "voteType": 1,
        "timestamp": "2025-08-26T23:50:19.154Z"
      },
      {
        "llmId": "gpt-4o",
        "voteType": 0,
        "timestamp": "2025-08-26T23:50:19.776Z"
      },
      {
        "llmId": "gpt-4o",
        "voteType": 1,
        "timestamp": "2025-08-26T23:50:21.309Z"
      },
      {
        "llmId": "gpt-4o",
        "voteType": -1,
        "timestamp": "2025-08-26T23:50:24.707Z"
      },
      {
        "llmId": "claude-3-5-sonnet",
        "voteType": -1,
        "timestamp": "2025-08-26T23:50:25.431Z"
      },
      {
        "llmId": "gemini-ultra",
        "voteType": -1,
        "timestamp": "2025-08-26T23:50:26.060Z"
      },
      {
        "llmId": "llama-3-70b",
        "voteType": -1,
        "timestamp": "2025-08-26T23:50:26.734Z"
      },
      {
        "llmId": "mistral-large",
        "voteType": -1,
        "timestamp": "2025-08-26T23:50:27.322Z"
      },
      {
        "llmId": "command-r-plus",
        "voteType": -1,
        "timestamp": "2025-08-26T23:50:27.861Z"
      },
      {
        "llmId": "grok",
        "voteType": -1,
        "timestamp": "2025-08-26T23:50:28.382Z"
      },
      {
        "llmId": "perplexity",
        "voteType": -1,
        "timestamp": "2025-08-26T23:50:29.269Z"
      },
      {
        "llmId": "qwen-2-5",
        "voteType": -1,
        "timestamp": "2025-08-26T23:50:29.899Z"
      },
      {
        "llmId": "deepseek-coder",
        "voteType": -1,
        "timestamp": "2025-08-26T23:50:30.371Z"
      },
      {
        "llmId": "phi-3",
        "voteType": -1,
        "timestamp": "2025-08-26T23:50:30.577Z"
      },
      {
        "llmId": "falcon-180b",
        "voteType": -1,
        "timestamp": "2025-08-26T23:50:30.757Z"
      },
      {
        "llmId": "vicuna-33b",
        "voteType": -1,
        "timestamp": "2025-08-26T23:50:31.098Z"
      },
      {
        "llmId": "solar-10-7b",
        "voteType": -1,
        "timestamp": "2025-08-26T23:50:31.279Z"
      },
      {
        "llmId": "yi-34b",
        "voteType": -1,
        "timestamp": "2025-08-26T23:50:31.472Z"
      },
      {
        "llmId": "mixtral-8x7b",
        "voteType": -1,
        "timestamp": "2025-08-26T23:50:35.524Z"
      },
      {
        "llmId": "bard",
        "voteType": -1,
        "timestamp": "2025-08-26T23:50:36.271Z"
      },
      {
        "llmId": "ernie-4",
        "voteType": -1,
        "timestamp": "2025-08-26T23:50:36.802Z"
      },
      {
        "llmId": "stablelm-2",
        "voteType": -1,
        "timestamp": "2025-08-26T23:50:38.234Z"
      },
      {
        "llmId": "inflection-2-5",
        "voteType": -1,
        "timestamp": "2025-08-26T23:50:38.910Z"
      },
      {
        "llmId": "gpt-4o",
        "voteType": 1,
        "timestamp": "2025-08-26T23:50:52.917Z"
      },
      {
        "llmId": "gpt-4o",
        "voteType": 0,
        "timestamp": "2025-08-26T23:50:53.560Z"
      },
      {
        "llmId": "gpt-4o",
        "voteType": 1,
        "timestamp": "2025-08-26T23:50:54.614Z"
      },
      {
        "llmId": "grok",
        "voteType": 1,
        "timestamp": "2025-08-26T23:50:56.529Z"
      },
      {
        "llmId": "claude-3-5-sonnet",
        "voteType": 1,
        "timestamp": "2025-08-27T00:11:53.770Z"
      },
      {
        "llmId": "claude-3-5-sonnet",
        "voteType": -1,
        "timestamp": "2025-08-27T00:11:56.831Z"
      },
      {
        "llmId": "claude-3-5-sonnet",
        "voteType": 1,
        "timestamp": "2025-08-27T00:11:59.213Z"
      },
      {
        "llmId": "command-r-plus",
        "voteType": 1,
        "timestamp": "2025-08-27T00:12:01.233Z"
      },
      {
        "llmId": "command-r-plus",
        "voteType": 0,
        "timestamp": "2025-08-27T00:12:03.173Z"
      },
      {
        "llmId": "command-r-plus",
        "voteType": 1,
        "timestamp": "2025-08-27T00:12:04.434Z"
      },
      {
        "llmId": "deepseek-coder",
        "voteType": 1,
        "timestamp": "2025-08-27T00:12:16.846Z"
      },
      {
        "llmId": "ernie-4",
        "voteType": 1,
        "timestamp": "2025-08-27T00:12:20.762Z"
      },
      {
        "llmId": "claude-3-5-sonnet",
        "voteType": -1,
        "timestamp": "2025-08-27T00:12:28.735Z"
      },
      {
        "llmId": "claude-3-5-sonnet",
        "voteType": 1,
        "timestamp": "2025-08-27T00:12:30.032Z"
      },
      {
        "llmId": "gpt-4o",
        "voteType": -1,
        "timestamp": "2025-08-27T00:12:53.558Z"
      },
      {
        "llmId": "gpt-4o",
        "voteType": 0,
        "timestamp": "2025-08-27T00:14:15.370Z"
      },
      {
        "llmId": "gpt-4o",
        "voteType": 1,
        "timestamp": "2025-08-27T00:14:16.932Z"
      },
      {
        "llmId": "claude-3-5-sonnet",
        "voteType": -1,
        "timestamp": "2025-08-27T00:14:19.561Z"
      },
      {
        "llmId": "claude-3-5-sonnet",
        "voteType": 1,
        "timestamp": "2025-08-27T00:14:22.294Z"
      }
    ],
    "dailyVotes": [
      [
        "Wed Aug 27 2025",
        44
      ]
    ]
  },
  "lastUpdated": "2025-08-27T00:14:22.294Z"
}

// File: c:\Users\Taimoor\Documents\GitHub\llm-popularity-tracker\lib\cache.js
import dbManager from './database.js';
import logger from './logger.js';

class CacheManager {
  constructor() {
    this.redis = null;
    this.defaultTTL = 3600; // 1 hour in seconds
  }

  async initialize() {
    this.redis = dbManager.getRedis();
  }

  // Vote counting cache
  async getVoteCount(llmId) {
    try {
      const cached = await this.redis.get(`vote_count:${llmId}`);
      return cached ? parseInt(cached, 10) : null;
    } catch (error) {
      logger.error('Redis get vote count failed:', error);
      return null;
    }
  }

  async setVoteCount(llmId, count, ttl = this.defaultTTL) {
    try {
      await this.redis.setex(`vote_count:${llmId}`, ttl, count.toString());
    } catch (error) {
      logger.error('Redis set vote count failed:', error);
    }
  }

  async incrementVoteCount(llmId, increment = 1) {
    try {
      const newCount = await this.redis.incrby(`vote_count:${llmId}`, increment);
      await this.redis.expire(`vote_count:${llmId}`, this.defaultTTL);
      return newCount;
    } catch (error) {
      logger.error('Redis increment vote count failed:', error);
      return null;
    }
  }

  // All votes cache
  async getAllVotes() {
    try {
      const cached = await this.redis.get('all_votes');
      return cached ? JSON.parse(cached) : null;
    } catch (error) {
      logger.error('Redis get all votes failed:', error);
      return null;
    }
  }

  async setAllVotes(votesData, ttl = 300) { // 5 minutes for all votes
    try {
      await this.redis.setex('all_votes', ttl, JSON.stringify(votesData));
    } catch (error) {
      logger.error('Redis set all votes failed:', error);
    }
  }

  // User session cache
  async getUserSession(fingerprint) {
    try {
      const cached = await this.redis.get(`user_session:${fingerprint}`);
      return cached ? JSON.parse(cached) : null;
    } catch (error) {
      logger.error('Redis get user session failed:', error);
      return null;
    }
  }

  async setUserSession(fingerprint, sessionData, ttl = 86400) { // 24 hours
    try {
      await this.redis.setex(
        `user_session:${fingerprint}`,
        ttl,
        JSON.stringify(sessionData)
      );
    } catch (error) {
      logger.error('Redis set user session failed:', error);
    }
  }

  // User votes cache
  async getUserVotes(fingerprint) {
    try {
      const cached = await this.redis.hgetall(`user_votes:${fingerprint}`);
      const votes = {};
      for (const [llmId, voteType] of Object.entries(cached)) {
        votes[llmId] = parseInt(voteType, 10);
      }
      return Object.keys(votes).length > 0 ? votes : null;
    } catch (error) {
      logger.error('Redis get user votes failed:', error);
      return null;
    }
  }

  async setUserVote(fingerprint, llmId, voteType) {
    try {
      if (voteType === 0) {
        await this.redis.hdel(`user_votes:${fingerprint}`, llmId);
      } else {
        await this.redis.hset(`user_votes:${fingerprint}`, llmId, voteType.toString());
      }
      await this.redis.expire(`user_votes:${fingerprint}`, 86400); // 24 hours
    } catch (error) {
      logger.error('Redis set user vote failed:', error);
    }
  }

  async setAllUserVotes(fingerprint, votes, ttl = 86400) {
    try {
      const pipeline = this.redis.pipeline();
      pipeline.del(`user_votes:${fingerprint}`);
      
      for (const [llmId, voteType] of Object.entries(votes)) {
        if (voteType !== 0) {
          pipeline.hset(`user_votes:${fingerprint}`, llmId, voteType.toString());
        }
      }
      
      pipeline.expire(`user_votes:${fingerprint}`, ttl);
      await pipeline.exec();
    } catch (error) {
      logger.error('Redis set all user votes failed:', error);
    }
  }

  // Rankings cache
  async getRankings() {
    try {
      const cached = await this.redis.get('rankings');
      return cached ? JSON.parse(cached) : null;
    } catch (error) {
      logger.error('Redis get rankings failed:', error);
      return null;
    }
  }

  async setRankings(rankings, ttl = 300) { // 5 minutes
    try {
      await this.redis.setex('rankings', ttl, JSON.stringify(rankings));
    } catch (error) {
      logger.error('Redis set rankings failed:', error);
    }
  }

  // Statistics cache
  async getStats() {
    try {
      const cached = await this.redis.get('stats');
      return cached ? JSON.parse(cached) : null;
    } catch (error) {
      logger.error('Redis get stats failed:', error);
      return null;
    }
  }

  async setStats(stats, ttl = 300) { // 5 minutes
    try {
      await this.redis.setex('stats', ttl, JSON.stringify(stats));
    } catch (error) {
      logger.error('Redis set stats failed:', error);
    }
  }

  // Rate limiting
  async checkRateLimit(key, maxRequests = 100, windowMs = 900000) { // 15 minutes default
    try {
      const current = await this.redis.incr(key);
      
      if (current === 1) {
        await this.redis.expire(key, Math.ceil(windowMs / 1000));
      }
      
      const ttl = await this.redis.ttl(key);
      
      return {
        totalRequests: current,
        remainingRequests: Math.max(0, maxRequests - current),
        resetTime: new Date(Date.now() + ttl * 1000),
        exceeded: current > maxRequests
      };
    } catch (error) {
      logger.error('Redis rate limit check failed:', error);
      return {
        totalRequests: 0,
        remainingRequests: maxRequests,
        resetTime: new Date(Date.now() + windowMs),
        exceeded: false
      };
    }
  }

  // Session tracking for fraud detection
  async trackUserActivity(fingerprint, activity) {
    try {
      const key = `activity:${fingerprint}`;
      const pipeline = this.redis.pipeline();
      
      pipeline.lpush(key, JSON.stringify({
        activity,
        timestamp: Date.now()
      }));
      pipeline.ltrim(key, 0, 99); // Keep last 100 activities
      pipeline.expire(key, 86400); // 24 hours
      
      await pipeline.exec();
    } catch (error) {
      logger.error('Redis track activity failed:', error);
    }
  }

  async getUserActivityHistory(fingerprint, limit = 20) {
    try {
      const activities = await this.redis.lrange(`activity:${fingerprint}`, 0, limit - 1);
      return activities.map(activity => JSON.parse(activity));
    } catch (error) {
      logger.error('Redis get activity history failed:', error);
      return [];
    }
  }

  // Real-time updates pub/sub
  async publishVoteUpdate(llmId, voteData) {
    try {
      await this.redis.publish('vote_updates', JSON.stringify({
        llmId,
        ...voteData,
        timestamp: Date.now()
      }));
    } catch (error) {
      logger.error('Redis publish vote update failed:', error);
    }
  }

  async subscribeToVoteUpdates(callback) {
    try {
      const subscriber = this.redis.duplicate();
      await subscriber.subscribe('vote_updates');
      subscriber.on('message', (channel, message) => {
        if (channel === 'vote_updates') {
          try {
            const data = JSON.parse(message);
            callback(data);
          } catch (error) {
            logger.error('Failed to parse vote update message:', error);
          }
        }
      });
      return subscriber;
    } catch (error) {
      logger.error('Redis subscribe to vote updates failed:', error);
      return null;
    }
  }

  // Cache invalidation
  async invalidateVoteCache(llmId) {
    try {
      const pipeline = this.redis.pipeline();
      pipeline.del(`vote_count:${llmId}`);
      pipeline.del('all_votes');
      pipeline.del('rankings');
      pipeline.del('stats');
      await pipeline.exec();
    } catch (error) {
      logger.error('Redis invalidate vote cache failed:', error);
    }
  }

  async invalidateAllCaches() {
    try {
      const pattern = 'vote_count:*';
      const keys = await this.redis.keys(pattern);
      
      if (keys.length > 0) {
        await this.redis.del(...keys);
      }
      
      await this.redis.del('all_votes', 'rankings', 'stats');
    } catch (error) {
      logger.error('Redis invalidate all caches failed:', error);
    }
  }

  // Cleanup expired keys
  async cleanup() {
    try {
      // This is handled automatically by Redis TTL, but we can add custom cleanup logic
      const expiredSessions = await this.redis.keys('user_session:*');
      let cleanedCount = 0;
      
      for (const key of expiredSessions) {
        const ttl = await this.redis.ttl(key);
        if (ttl === -1) { // Key exists but has no TTL
          await this.redis.expire(key, 86400); // Set 24 hour TTL
          cleanedCount++;
        }
      }
      
      if (cleanedCount > 0) {
        logger.info(`Cleaned up ${cleanedCount} session keys without TTL`);
      }
    } catch (error) {
      logger.error('Redis cleanup failed:', error);
    }
  }

  // Health check
  async healthCheck() {
    try {
      const start = Date.now();
      await this.redis.ping();
      const latency = Date.now() - start;
      
      return {
        status: 'healthy',
        latency: `${latency}ms`
      };
    } catch (error) {
      return {
        status: 'unhealthy',
        error: error.message
      };
    }
  }
}

// Singleton instance
const cacheManager = new CacheManager();

export default cacheManager;

// File: c:\Users\Taimoor\Documents\GitHub\llm-popularity-tracker\lib\config.js
// Configuration helper to manage environment variables
// Falls back to file-based storage if database is not configured

const config = {
  // Database configuration
  database: {
    enabled: process.env.POSTGRES_HOST && process.env.POSTGRES_HOST !== 'localhost',
    host: process.env.POSTGRES_HOST || 'localhost',
    port: parseInt(process.env.POSTGRES_PORT || '5432'),
    database: process.env.POSTGRES_DB || 'llm_tracker',
    user: process.env.POSTGRES_USER || 'postgres',
    password: process.env.POSTGRES_PASSWORD || 'password',
    url: process.env.DATABASE_URL,
  },
  
  // Redis configuration
  redis: {
    enabled: process.env.REDIS_HOST && process.env.REDIS_HOST !== 'localhost',
    host: process.env.REDIS_HOST || 'localhost',
    port: parseInt(process.env.REDIS_PORT || '6379'),
    password: process.env.REDIS_PASSWORD || undefined,
    url: process.env.REDIS_URL,
  },
  
  // Application settings
  app: {
    env: process.env.NODE_ENV || 'development',
    port: parseInt(process.env.PORT || '3000'),
    logLevel: process.env.LOG_LEVEL || 'info',
  },
  
  // Security settings
  security: {
    jwtSecret: process.env.JWT_SECRET || 'development-secret-change-in-production',
    jwtExpiresIn: process.env.JWT_EXPIRES_IN || '7d',
    sessionSecret: process.env.SESSION_SECRET || 'session-secret-change-in-production',
    bcryptRounds: parseInt(process.env.BCRYPT_ROUNDS || '12'),
  },
  
  // Rate limiting
  rateLimit: {
    maxRequests: parseInt(process.env.RATE_LIMIT_MAX || '100'),
    windowMs: parseInt(process.env.RATE_LIMIT_WINDOW_MS || '900000'),
  },
  
  // Feature flags
  features: {
    analytics: process.env.ENABLE_ANALYTICS === 'true',
    realTime: process.env.ENABLE_REAL_TIME === 'true',
    useDatabase: false, // Will be determined below
  },
};

// Determine if we should use database or file storage
// Use database only if both PostgreSQL and Redis are properly configured
config.features.useDatabase = !!(
  (config.database.enabled || config.database.url) &&
  (config.redis.enabled || config.redis.url)
);

// Log configuration status (without sensitive data)
if (typeof window === 'undefined') { // Only on server side
  console.log('Configuration loaded:', {
    environment: config.app.env,
    databaseEnabled: config.features.useDatabase,
    redisEnabled: config.redis.enabled,
    features: config.features,
  });
}

export default config;

// File: c:\Users\Taimoor\Documents\GitHub\llm-popularity-tracker\lib\database.js
import { Pool } from 'pg';
import Redis from 'ioredis';
import logger from './logger.js';

class DatabaseManager {
  constructor() {
    this.pool = null;
    this.redis = null;
  }

  async initializePostgres() {
    try {
      this.pool = new Pool({
        host: process.env.POSTGRES_HOST || 'localhost',
        port: process.env.POSTGRES_PORT || 5432,
        database: process.env.POSTGRES_DB || 'llm_tracker',
        user: process.env.POSTGRES_USER || 'postgres',
        password: process.env.POSTGRES_PASSWORD || 'password',
        max: 20, // Maximum pool size
        idleTimeoutMillis: 30000, // Close idle clients after 30 seconds
        connectionTimeoutMillis: 2000, // Return error after 2 seconds if connection could not be established
        statement_timeout: 10000, // Terminate any statement that takes over 10 seconds
        query_timeout: 10000, // Terminate any query that takes over 10 seconds
        application_name: 'llm-popularity-tracker',
        ssl: process.env.NODE_ENV === 'production' ? { rejectUnauthorized: false } : false
      });

      // Test connection
      const client = await this.pool.connect();
      await client.query('SELECT NOW()');
      client.release();
      
      logger.info('PostgreSQL connection pool initialized successfully');
    } catch (error) {
      logger.error('Failed to initialize PostgreSQL:', error);
      throw error;
    }
  }

  async initializeRedis() {
    try {
      const redisConfig = {
        host: process.env.REDIS_HOST || 'localhost',
        port: process.env.REDIS_PORT || 6379,
        password: process.env.REDIS_PASSWORD || undefined,
        retryDelayOnFailover: 100,
        maxRetriesPerRequest: 3,
        lazyConnect: true,
        keepAlive: 30000,
        family: 4, // Force IPv4
        connectTimeout: 10000,
        commandTimeout: 5000,
      };

      this.redis = new Redis(redisConfig);
      
      // Test connection
      await this.redis.connect();
      await this.redis.ping();
      
      this.redis.on('error', (error) => {
        logger.error('Redis error:', error);
      });

      this.redis.on('connect', () => {
        logger.info('Redis connected successfully');
      });

      this.redis.on('ready', () => {
        logger.info('Redis ready to accept commands');
      });

      logger.info('Redis connection initialized successfully');
    } catch (error) {
      logger.error('Failed to initialize Redis:', error);
      throw error;
    }
  }

  async initialize() {
    await Promise.all([
      this.initializePostgres(),
      this.initializeRedis()
    ]);
  }

  getPool() {
    if (!this.pool) {
      throw new Error('Database pool not initialized. Call initialize() first.');
    }
    return this.pool;
  }

  getRedis() {
    if (!this.redis) {
      throw new Error('Redis not initialized. Call initialize() first.');
    }
    return this.redis;
  }

  async query(text, params = []) {
    const start = Date.now();
    try {
      const result = await this.pool.query(text, params);
      const duration = Date.now() - start;
      logger.debug('Query executed', { 
        query: text, 
        duration: `${duration}ms`, 
        rows: result.rowCount 
      });
      return result;
    } catch (error) {
      const duration = Date.now() - start;
      logger.error('Query failed', { 
        query: text, 
        duration: `${duration}ms`, 
        error: error.message 
      });
      throw error;
    }
  }

  async transaction(callback) {
    const client = await this.pool.connect();
    try {
      await client.query('BEGIN');
      const result = await callback(client);
      await client.query('COMMIT');
      return result;
    } catch (error) {
      await client.query('ROLLBACK');
      throw error;
    } finally {
      client.release();
    }
  }

  async closeAll() {
    const promises = [];
    
    if (this.pool) {
      promises.push(this.pool.end());
    }
    
    if (this.redis) {
      promises.push(this.redis.quit());
    }
    
    await Promise.all(promises);
    logger.info('All database connections closed');
  }

  // Health check methods
  async healthCheck() {
    const results = {
      postgres: false,
      redis: false,
      timestamp: new Date().toISOString()
    };

    try {
      await this.pool.query('SELECT 1');
      results.postgres = true;
    } catch (error) {
      logger.error('PostgreSQL health check failed:', error);
    }

    try {
      await this.redis.ping();
      results.redis = true;
    } catch (error) {
      logger.error('Redis health check failed:', error);
    }

    return results;
  }
}

// Singleton instance
const dbManager = new DatabaseManager();

export default dbManager;

// File: c:\Users\Taimoor\Documents\GitHub\llm-popularity-tracker\lib\fingerprint.js
import FingerprintJS from '@fingerprintjs/fingerprintjs';

class FingerprintService {
  constructor() {
    this.fpPromise = null;
    this.cachedFingerprint = null;
    this.storageKey = 'llm-tracker-fingerprint';
  }

  async initialize() {
    if (!this.fpPromise) {
      this.fpPromise = FingerprintJS.load();
    }
    return this.fpPromise;
  }

  async getFingerprint() {
    // Return cached fingerprint if available
    if (this.cachedFingerprint) {
      return this.cachedFingerprint;
    }

    // Try to get from localStorage first
    const storedFingerprint = this.getStoredFingerprint();
    if (storedFingerprint) {
      this.cachedFingerprint = storedFingerprint;
      return storedFingerprint;
    }

    // Generate new fingerprint
    try {
      const fp = await this.initialize();
      const result = await fp.get();
      const fingerprint = result.visitorId;
      
      // Store for future use
      this.storeFingerprint(fingerprint);
      this.cachedFingerprint = fingerprint;
      
      return fingerprint;
    } catch (error) {
      console.error('Failed to generate fingerprint:', error);
      // Fallback to a random ID stored in localStorage
      return this.generateFallbackFingerprint();
    }
  }

  getStoredFingerprint() {
    if (typeof window === 'undefined') return null;
    
    try {
      return localStorage.getItem(this.storageKey);
    } catch (error) {
      console.error('Failed to read stored fingerprint:', error);
      return null;
    }
  }

  storeFingerprint(fingerprint) {
    if (typeof window === 'undefined') return;
    
    try {
      localStorage.setItem(this.storageKey, fingerprint);
      // Also store in sessionStorage as backup
      sessionStorage.setItem(this.storageKey, fingerprint);
    } catch (error) {
      console.error('Failed to store fingerprint:', error);
    }
  }

  generateFallbackFingerprint() {
    // Generate a random fallback ID
    const fallbackId = 'fallback_' + Math.random().toString(36).substring(2) + Date.now().toString(36);
    this.storeFingerprint(fallbackId);
    this.cachedFingerprint = fallbackId;
    return fallbackId;
  }

  // Get fingerprint with multiple fallback options
  async getFingerprintWithFallbacks() {
    // Primary: Generated fingerprint
    try {
      return await this.getFingerprint();
    } catch (error) {
      console.error('Primary fingerprint failed:', error);
    }

    // Secondary: SessionStorage
    try {
      const sessionFingerprint = sessionStorage.getItem(this.storageKey);
      if (sessionFingerprint) {
        this.cachedFingerprint = sessionFingerprint;
        return sessionFingerprint;
      }
    } catch (error) {
      console.error('SessionStorage fallback failed:', error);
    }

    // Tertiary: Generate new fallback
    return this.generateFallbackFingerprint();
  }

  // Clear stored fingerprint (for testing or user request)
  clearFingerprint() {
    this.cachedFingerprint = null;
    if (typeof window !== 'undefined') {
      try {
        localStorage.removeItem(this.storageKey);
        sessionStorage.removeItem(this.storageKey);
      } catch (error) {
        console.error('Failed to clear fingerprint:', error);
      }
    }
  }
}

// Singleton instance
const fingerprintService = new FingerprintService();

export default fingerprintService;

// File: c:\Users\Taimoor\Documents\GitHub\llm-popularity-tracker\lib\llm-data.js
export const llmData = [
  {
    id: "gpt-4o",
    name: "GPT-4o",
    company: "OpenAI",
    description: "Most advanced multimodal AI with vision, analysis, and coding capabilities",
    useCases: ["General purpose", "Code generation", "Creative writing", "Vision tasks"],
    releaseYear: 2024,
    color: "from-green-500 to-emerald-600",
    logo: "🤖",
    image: "https://upload.wikimedia.org/wikipedia/commons/thumb/4/4d/OpenAI_Logo.svg/200px-OpenAI_Logo.svg.png",
  },
  {
    id: "claude-3-5-sonnet",
    name: "Claude 3.5 Sonnet",
    company: "Anthropic",
    description: "Balanced model excelling at analysis, coding, and nuanced conversation",
    useCases: ["Code analysis", "Research", "Writing", "Complex reasoning"],
    releaseYear: 2024,
    color: "from-orange-500 to-amber-600",
    logo: "🧠",
    image: "https://www.anthropic.com/_next/static/media/claude-logo.2f5f0b53.svg",
  },
  {
    id: "gemini-ultra",
    name: "Gemini Ultra",
    company: "Google",
    description: "Google's flagship model with strong multimodal and reasoning abilities",
    useCases: ["Multimodal tasks", "Scientific research", "Code", "Mathematics"],
    releaseYear: 2024,
    color: "from-blue-500 to-cyan-600",
    logo: "💎",
    image: "https://www.gstatic.com/lamda/images/gemini_sparkle_v002_d4735304ff6292a690345.svg",
  },
  {
    id: "llama-3-70b",
    name: "Llama 3 70B",
    company: "Meta",
    description: "Open-source powerhouse for customizable AI applications",
    useCases: ["Open source projects", "Fine-tuning", "Research", "Commercial use"],
    releaseYear: 2024,
    color: "from-purple-500 to-violet-600",
    logo: "🦙",
    image: "https://upload.wikimedia.org/wikipedia/commons/thumb/7/7b/Meta_Platforms_Inc._logo.svg/200px-Meta_Platforms_Inc._logo.svg.png",
  },
  {
    id: "mistral-large",
    name: "Mistral Large",
    company: "Mistral AI",
    description: "European AI champion with strong multilingual capabilities",
    useCases: ["Multilingual tasks", "European languages", "Code", "Efficiency"],
    releaseYear: 2024,
    color: "from-red-500 to-pink-600",
    logo: "🌪️",
    image: "https://docs.mistral.ai/img/logo.svg",
  },
  {
    id: "command-r-plus",
    name: "Command R+",
    company: "Cohere",
    description: "Enterprise-focused with excellent retrieval and grounding",
    useCases: ["Enterprise search", "RAG systems", "Document analysis", "Business"],
    releaseYear: 2024,
    color: "from-indigo-500 to-blue-600",
    logo: "📊",
    image: "https://cohere.com/favicon.svg",
  },
  {
    id: "grok",
    name: "Grok",
    company: "xAI",
    description: "Real-time knowledge with humor and unconventional responses",
    useCases: ["Real-time info", "Social media", "Humor", "Current events"],
    releaseYear: 2023,
    color: "from-gray-600 to-slate-700",
    logo: "🚀",
    image: "https://grok.x.ai/assets/grok-logo-light.svg",
  },
  {
    id: "perplexity",
    name: "Perplexity",
    company: "Perplexity AI",
    description: "Search-enhanced AI with real-time web access and citations",
    useCases: ["Web search", "Research", "Fact-checking", "Citations"],
    releaseYear: 2024,
    color: "from-teal-500 to-cyan-600",
    logo: "🔍",
    image: "https://www.perplexity.ai/favicon.svg",
  },
  {
    id: "qwen-2-5",
    name: "Qwen 2.5",
    company: "Alibaba",
    description: "Strong Asian language support with competitive performance",
    useCases: ["Chinese language", "Asian markets", "E-commerce", "Translation"],
    releaseYear: 2024,
    color: "from-yellow-500 to-orange-600",
    logo: "🐉",
    image: "https://upload.wikimedia.org/wikipedia/commons/thumb/2/26/Alibaba-Logo.svg/200px-Alibaba-Logo.svg.png",
  },
  {
    id: "deepseek-coder",
    name: "DeepSeek Coder",
    company: "DeepSeek",
    description: "Specialized coding model with excellent debugging capabilities",
    useCases: ["Code generation", "Debugging", "Code review", "Documentation"],
    releaseYear: 2024,
    color: "from-green-600 to-teal-700",
    logo: "💻",
    image: "https://github.com/deepseek-ai.png",
  },
  {
    id: "phi-3",
    name: "Phi-3",
    company: "Microsoft",
    description: "Small but mighty model optimized for edge deployment",
    useCases: ["Edge computing", "Mobile apps", "Low resource", "Fast inference"],
    releaseYear: 2024,
    color: "from-blue-600 to-indigo-700",
    logo: "⚡",
    image: "https://upload.wikimedia.org/wikipedia/commons/thumb/4/44/Microsoft_logo.svg/200px-Microsoft_logo.svg.png",
  },
  {
    id: "falcon-180b",
    name: "Falcon 180B",
    company: "TII UAE",
    description: "Open-source giant with strong performance across tasks",
    useCases: ["Open source", "Research", "Arabic language", "General purpose"],
    releaseYear: 2023,
    color: "from-amber-600 to-yellow-700",
    logo: "🦅",
    image: "https://www.tii.ae/sites/default/files/2022-12/TII-logo-WHITE.png",
  },
  {
    id: "vicuna-33b",
    name: "Vicuna-33B",
    company: "LMSYS",
    description: "Fine-tuned Llama model with improved conversational abilities",
    useCases: ["Chatbots", "Open source", "Fine-tuning base", "Research"],
    releaseYear: 2023,
    color: "from-pink-500 to-rose-600",
    logo: "🦌",
    image: "https://github.com/lm-sys.png",
  },
  {
    id: "solar-10-7b",
    name: "SOLAR-10.7B",
    company: "Upstage AI",
    description: "Efficient Korean model with strong multilingual capabilities",
    useCases: ["Korean language", "Efficient inference", "Asian languages", "Small models"],
    releaseYear: 2024,
    color: "from-orange-600 to-red-700",
    logo: "☀️",
    image: "https://github.com/UpstageAI.png",
  },
  {
    id: "yi-34b",
    name: "Yi-34B",
    company: "01.AI",
    description: "Bilingual model excelling in Chinese and English tasks",
    useCases: ["Chinese-English", "Translation", "Bilingual tasks", "Open source"],
    releaseYear: 2024,
    color: "from-purple-600 to-pink-700",
    logo: "🎭",
    image: "https://github.com/01-ai.png",
  },
  {
    id: "mixtral-8x7b",
    name: "Mixtral 8x7B",
    company: "Mistral AI",
    description: "Mixture of experts model with excellent efficiency",
    useCases: ["Efficient inference", "MoE architecture", "Code", "Multiple languages"],
    releaseYear: 2024,
    color: "from-violet-600 to-purple-700",
    logo: "🎨",
    image: "https://docs.mistral.ai/img/logo.svg",
  },
  {
    id: "bard",
    name: "Bard (Gemini Pro)",
    company: "Google",
    description: "Google's conversational AI with web access and multimodal features",
    useCases: ["Web browsing", "Conversation", "Creative tasks", "Integration"],
    releaseYear: 2024,
    color: "from-blue-500 to-green-600",
    logo: "🎭",
    image: "https://www.gstatic.com/lamda/images/gemini_sparkle_v002_d4735304ff6292a690345.svg",
  },
  {
    id: "ernie-4",
    name: "ERNIE 4.0",
    company: "Baidu",
    description: "Chinese AI leader with strong understanding of Chinese culture",
    useCases: ["Chinese market", "Cultural context", "Search", "Business"],
    releaseYear: 2024,
    color: "from-red-600 to-orange-700",
    logo: "🏮",
    image: "https://upload.wikimedia.org/wikipedia/en/thumb/3/37/Baidu_Logo.svg/200px-Baidu_Logo.svg.png",
  },
  {
    id: "stablelm-2",
    name: "StableLM 2",
    company: "Stability AI",
    description: "Open model from the makers of Stable Diffusion",
    useCases: ["Open source", "Customization", "Research", "Creative apps"],
    releaseYear: 2024,
    color: "from-purple-500 to-indigo-600",
    logo: "🎯",
    image: "https://github.com/Stability-AI.png",
  },
  {
    id: "inflection-2-5",
    name: "Inflection-2.5",
    company: "Inflection AI",
    description: "Personal AI with empathetic and supportive conversation style",
    useCases: ["Personal assistant", "Emotional support", "Coaching", "Companionship"],
    releaseYear: 2024,
    color: "from-teal-600 to-blue-700",
    logo: "💬",
    image: "https://github.com/InflectionAI.png",
  },
];

// File: c:\Users\Taimoor\Documents\GitHub\llm-popularity-tracker\lib\logger.js
import pino from 'pino';
import pretty from 'pino-pretty';

const isDevelopment = process.env.NODE_ENV === 'development';
const logLevel = process.env.LOG_LEVEL || 'info';

// Create logger configuration
const loggerConfig = {
  level: logLevel,
  timestamp: pino.stdTimeFunctions.isoTime,
  formatters: {
    level: (label) => {
      return { level: label.toUpperCase() };
    },
  },
  serializers: {
    err: pino.stdSerializers.err,
    req: (req) => ({
      method: req.method,
      url: req.url,
      headers: {
        'user-agent': req.headers['user-agent'],
        'x-forwarded-for': req.headers['x-forwarded-for'],
        'x-real-ip': req.headers['x-real-ip'],
      },
      remoteAddress: req.connection?.remoteAddress,
      remotePort: req.connection?.remotePort,
    }),
    res: (res) => ({
      statusCode: res.statusCode,
      headers: {
        'content-type': res.headers['content-type'],
        'content-length': res.headers['content-length'],
      },
    }),
  },
};

// Create logger instance
let logger;

if (isDevelopment) {
  // Pretty print for development
  logger = pino(
    loggerConfig,
    pretty({
      colorize: true,
      translateTime: 'SYS:standard',
      ignore: 'pid,hostname',
    })
  );
} else {
  // JSON format for production
  logger = pino(loggerConfig);
}

// Create child loggers for different modules
const createChildLogger = (module) => {
  return logger.child({ module });
};

// Export logger with additional methods
const enhancedLogger = {
  ...logger,
  child: createChildLogger,
  
  // Request logging middleware
  logRequest: (req, res, next) => {
    const start = Date.now();
    const requestId = req.headers['x-request-id'] || Math.random().toString(36).substr(2, 9);
    
    req.log = logger.child({ requestId });
    
    req.log.info({
      req,
      event: 'request-start'
    }, 'Request started');
    
    const originalEnd = res.end;
    res.end = function(...args) {
      const duration = Date.now() - start;
      req.log.info({
        res,
        event: 'request-end',
        duration: `${duration}ms`
      }, 'Request completed');
      
      originalEnd.apply(this, args);
    };
    
    if (next) next();
  },
  
  // Security event logging
  security: {
    loginAttempt: (fingerprint, success, reason = null) => {
      logger.warn({
        event: 'login-attempt',
        fingerprint: fingerprint?.substring(0, 8) + '...',
        success,
        reason,
        timestamp: new Date().toISOString()
      }, `Login attempt ${success ? 'succeeded' : 'failed'}`);
    },
    
    rateLimitExceeded: (ip, endpoint, limit) => {
      logger.warn({
        event: 'rate-limit-exceeded',
        ip: ip?.substring(0, 8) + '...',
        endpoint,
        limit,
        timestamp: new Date().toISOString()
      }, 'Rate limit exceeded');
    },
    
    suspiciousActivity: (fingerprint, activity, details) => {
      logger.error({
        event: 'suspicious-activity',
        fingerprint: fingerprint?.substring(0, 8) + '...',
        activity,
        details,
        timestamp: new Date().toISOString()
      }, 'Suspicious activity detected');
    }
  },
  
  // Performance logging
  performance: {
    dbQuery: (query, duration, rows) => {
      const level = duration > 1000 ? 'warn' : duration > 500 ? 'info' : 'debug';
      logger[level]({
        event: 'db-query',
        query: query?.substring(0, 100) + (query?.length > 100 ? '...' : ''),
        duration: `${duration}ms`,
        rows,
        timestamp: new Date().toISOString()
      }, 'Database query executed');
    },
    
    apiResponse: (endpoint, method, duration, statusCode) => {
      const level = duration > 2000 ? 'warn' : duration > 1000 ? 'info' : 'debug';
      logger[level]({
        event: 'api-response',
        endpoint,
        method,
        duration: `${duration}ms`,
        statusCode,
        timestamp: new Date().toISOString()
      }, 'API response');
    }
  },
  
  // Business logic logging
  business: {
    voteSubmitted: (fingerprint, llmId, voteType, previousVote) => {
      logger.info({
        event: 'vote-submitted',
        fingerprint: fingerprint?.substring(0, 8) + '...',
        llmId,
        voteType,
        previousVote,
        timestamp: new Date().toISOString()
      }, 'Vote submitted');
    },
    
    fraudulentVoteDetected: (fingerprint, reason, details) => {
      logger.error({
        event: 'fraudulent-vote-detected',
        fingerprint: fingerprint?.substring(0, 8) + '...',
        reason,
        details,
        timestamp: new Date().toISOString()
      }, 'Fraudulent vote detected');
    }
  }
};

export default enhancedLogger;

// File: c:\Users\Taimoor\Documents\GitHub\llm-popularity-tracker\lib\middleware.js
import Joi from 'joi';
import { NextResponse } from 'next/server';
import cacheManager from './cache.js';
import logger from './logger.js';

// Input validation schemas
const schemas = {
  vote: Joi.object({
    fingerprint: Joi.string().required().min(10).max(255),
    llmId: Joi.string().required().min(1).max(255),
    voteType: Joi.number().integer().valid(-1, 0, 1).required()
  }),
  
  sync: Joi.object({
    fingerprint: Joi.string().required().min(10).max(255)
  }),
  
  fingerprint: Joi.string().alphanum().min(10).max(255)
};

// Get client IP helper
function getClientIP(request) {
  const forwarded = request.headers.get('x-forwarded-for');
  const realIP = request.headers.get('x-real-ip');
  const remoteAddress = request.headers.get('remote-address');
  
  if (forwarded) {
    return forwarded.split(',')[0].trim();
  }
  
  return realIP || remoteAddress || 'unknown';
}

// Get user agent helper
function getUserAgent(request) {
  return request.headers.get('user-agent') || 'unknown';
}

// Rate limiting middleware
export async function rateLimit(request, options = {}) {
  const {
    maxRequests = 100,
    windowMs = 900000, // 15 minutes
    keyGenerator = (req) => getClientIP(req),
    skipSuccessfulRequests = false,
    skipFailedRequests = false
  } = options;

  try {
    const key = `rate_limit:${keyGenerator(request)}`;
    const rateLimitInfo = await cacheManager.checkRateLimit(key, maxRequests, windowMs);
    
    if (rateLimitInfo.exceeded) {
      logger.security.rateLimitExceeded(
        getClientIP(request),
        new URL(request.url).pathname,
        maxRequests
      );
      
      return NextResponse.json(
        {
          error: 'Rate limit exceeded',
          message: `Too many requests. Limit: ${maxRequests} per ${Math.floor(windowMs / 1000 / 60)} minutes`,
          retryAfter: rateLimitInfo.resetTime.toISOString()
        },
        { 
          status: 429,
          headers: {
            'X-RateLimit-Limit': maxRequests.toString(),
            'X-RateLimit-Remaining': rateLimitInfo.remainingRequests.toString(),
            'X-RateLimit-Reset': Math.floor(rateLimitInfo.resetTime.getTime() / 1000).toString(),
            'Retry-After': Math.ceil((rateLimitInfo.resetTime.getTime() - Date.now()) / 1000).toString()
          }
        }
      );
    }
    
    // Add rate limit headers to response
    return {
      rateLimitHeaders: {
        'X-RateLimit-Limit': maxRequests.toString(),
        'X-RateLimit-Remaining': rateLimitInfo.remainingRequests.toString(),
        'X-RateLimit-Reset': Math.floor(rateLimitInfo.resetTime.getTime() / 1000).toString()
      }
    };
  } catch (error) {
    logger.error('Rate limiting failed:', error);
    // Allow request to continue if rate limiting fails
    return null;
  }
}

// Input validation middleware
export function validateInput(schema, data) {
  try {
    const { error, value } = schema.validate(data, {
      stripUnknown: true,
      abortEarly: false
    });
    
    if (error) {
      const errorMessages = error.details.map(detail => ({
        field: detail.path.join('.'),
        message: detail.message,
        value: detail.context?.value
      }));
      
      return {
        isValid: false,
        errors: errorMessages,
        data: null
      };
    }
    
    return {
      isValid: true,
      errors: null,
      data: value
    };
  } catch (error) {
    logger.error('Input validation failed:', error);
    return {
      isValid: false,
      errors: [{ field: 'unknown', message: 'Validation error occurred' }],
      data: null
    };
  }
}

// Security headers middleware
export function securityHeaders() {
  return {
    'X-Frame-Options': 'DENY',
    'X-Content-Type-Options': 'nosniff',
    'X-XSS-Protection': '1; mode=block',
    'Referrer-Policy': 'strict-origin-when-cross-origin',
    'Content-Security-Policy': "default-src 'self'; script-src 'self' 'unsafe-eval' 'unsafe-inline'; style-src 'self' 'unsafe-inline'; img-src 'self' data: https:; font-src 'self' data:; connect-src 'self' ws: wss:",
    'Strict-Transport-Security': 'max-age=31536000; includeSubDomains',
    'Permissions-Policy': 'geolocation=(), microphone=(), camera=()'
  };
}

// Request logging middleware
export function logRequest(request, startTime = Date.now()) {
  const ip = getClientIP(request);
  const userAgent = getUserAgent(request);
  const method = request.method;
  const url = new URL(request.url);
  const path = url.pathname;
  
  logger.info({
    event: 'request-start',
    method,
    path,
    ip: ip.substring(0, 8) + '...',
    userAgent: userAgent.substring(0, 100),
    timestamp: new Date().toISOString()
  }, `${method} ${path}`);
  
  return {
    ip,
    userAgent,
    method,
    path,
    startTime
  };
}

// Response logging middleware
export function logResponse(requestInfo, response, error = null) {
  const duration = Date.now() - requestInfo.startTime;
  const status = response?.status || (error ? 500 : 200);
  
  const logLevel = error ? 'error' : status >= 400 ? 'warn' : 'info';
  
  logger[logLevel]({
    event: 'request-end',
    method: requestInfo.method,
    path: requestInfo.path,
    status,
    duration: `${duration}ms`,
    ip: requestInfo.ip.substring(0, 8) + '...',
    error: error?.message,
    timestamp: new Date().toISOString()
  }, `${requestInfo.method} ${requestInfo.path} ${status} ${duration}ms`);
}

// Fraud detection middleware
export async function detectFraud(fingerprint, activity, context = {}) {
  try {
    const suspiciousIndicators = [];
    
    // Track activity
    await cacheManager.trackUserActivity(fingerprint, {
      type: activity,
      context,
      timestamp: Date.now()
    });
    
    // Get recent activity history
    const recentActivity = await cacheManager.getUserActivityHistory(fingerprint, 50);
    
    // Check for suspicious patterns
    
    // 1. Too many votes in short time
    if (activity === 'vote') {
      const recentVotes = recentActivity.filter(a => 
        a.activity.type === 'vote' && 
        Date.now() - a.activity.timestamp < 60000 // Last minute
      );
      
      if (recentVotes.length > 10) {
        suspiciousIndicators.push('rapid_voting');
      }
    }
    
    // 2. Repeated identical requests
    const identicalRequests = recentActivity.filter(a => 
      JSON.stringify(a.activity.context) === JSON.stringify(context) &&
      Date.now() - a.activity.timestamp < 300000 // Last 5 minutes
    );
    
    if (identicalRequests.length > 5) {
      suspiciousIndicators.push('repeated_requests');
    }
    
    // 3. Unusual voting patterns (alternating votes rapidly)
    if (activity === 'vote') {
      const recentVoteChanges = recentActivity
        .filter(a => a.activity.type === 'vote')
        .slice(0, 10);
      
      let alternatingPattern = 0;
      for (let i = 1; i < recentVoteChanges.length; i++) {
        const current = recentVoteChanges[i - 1].activity.context.voteType;
        const previous = recentVoteChanges[i].activity.context.voteType;
        if (current !== previous) {
          alternatingPattern++;
        }
      }
      
      if (alternatingPattern >= 5) {
        suspiciousIndicators.push('alternating_votes');
      }
    }
    
    // Log suspicious activity
    if (suspiciousIndicators.length > 0) {
      logger.security.suspiciousActivity(
        fingerprint,
        activity,
        {
          indicators: suspiciousIndicators,
          context,
          recentActivityCount: recentActivity.length
        }
      );
      
      return {
        isSuspicious: true,
        indicators: suspiciousIndicators,
        riskScore: suspiciousIndicators.length * 25 // 0-100 scale
      };
    }
    
    return {
      isSuspicious: false,
      indicators: [],
      riskScore: 0
    };
  } catch (error) {
    logger.error('Fraud detection failed:', error);
    return {
      isSuspicious: false,
      indicators: [],
      riskScore: 0
    };
  }
}

// Combined middleware for API routes
export async function apiMiddleware(request, options = {}) {
  const startTime = Date.now();
  const requestInfo = logRequest(request, startTime);
  
  try {
    // Apply rate limiting
    const rateLimitResult = await rateLimit(request, options.rateLimit);
    if (rateLimitResult?.status === 429) {
      logResponse(requestInfo, rateLimitResult);
      return rateLimitResult;
    }
    
    // Parse and validate request body if it exists
    let validatedData = null;
    if (request.method !== 'GET' && options.schema) {
      try {
        const body = await request.json();
        const validation = validateInput(options.schema, body);
        
        if (!validation.isValid) {
          const errorResponse = NextResponse.json(
            {
              error: 'Validation failed',
              details: validation.errors
            },
            { status: 400 }
          );
          
          logResponse(requestInfo, errorResponse);
          return errorResponse;
        }
        
        validatedData = validation.data;
      } catch (error) {
        const errorResponse = NextResponse.json(
          { error: 'Invalid JSON in request body' },
          { status: 400 }
        );
        
        logResponse(requestInfo, errorResponse);
        return errorResponse;
      }
    }
    
    return {
      success: true,
      requestInfo,
      validatedData,
      rateLimitHeaders: rateLimitResult?.rateLimitHeaders || {}
    };
  } catch (error) {
    logger.error('API middleware failed:', error);
    const errorResponse = NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    );
    
    logResponse(requestInfo, errorResponse, error);
    return errorResponse;
  }
}

// Export schemas for use in route handlers
export { schemas };

// File: c:\Users\Taimoor\Documents\GitHub\llm-popularity-tracker\lib\vote-manager-db.js
import dbManager from './database.js';
import cacheManager from './cache.js';
import logger from './logger.js';

class DatabaseVoteManager {
  constructor() {
    this.initialized = false;
  }

  async initialize() {
    if (this.initialized) return;
    
    try {
      await dbManager.initialize();
      await cacheManager.initialize();
      this.initialized = true;
      logger.info('DatabaseVoteManager initialized successfully');
    } catch (error) {
      logger.error('Failed to initialize DatabaseVoteManager:', error);
      throw error;
    }
  }

  async vote(fingerprint, llmId, voteType, metadata = {}) {
    await this.initialize();
    
    try {
      return await dbManager.transaction(async (client) => {
        // Get or create user session
        let userSession = await this.getOrCreateUserSession(client, fingerprint, metadata);
        
        // Check for existing vote
        const { rows: existingVotes } = await client.query(
          'SELECT vote_type FROM user_votes WHERE fingerprint = $1 AND llm_id = $2',
          [fingerprint, llmId]
        );
        
        const currentVote = existingVotes[0]?.vote_type || 0;
        const voteChange = voteType - currentVote;
        
        if (voteChange === 0) {
          return { success: false, error: 'Vote unchanged' };
        }
        
        // Update or insert user vote
        if (currentVote === 0 && voteType !== 0) {
          // New vote
          await client.query(
            `INSERT INTO user_votes (fingerprint, llm_id, vote_type, previous_vote, ip_address, user_agent)
             VALUES ($1, $2, $3, $4, $5, $6)`,
            [fingerprint, llmId, voteType, currentVote, metadata.ip || null, metadata.userAgent || null]
          );
        } else if (voteType === 0) {
          // Remove vote
          await client.query(
            'DELETE FROM user_votes WHERE fingerprint = $1 AND llm_id = $2',
            [fingerprint, llmId]
          );
        } else {
          // Update vote
          await client.query(
            `UPDATE user_votes 
             SET vote_type = $3, previous_vote = $4, updated_at = NOW()
             WHERE fingerprint = $1 AND llm_id = $2`,
            [fingerprint, llmId, voteType, currentVote]
          );
        }
        
        // Update aggregate votes
        const { rows: voteRows } = await client.query(
          'SELECT * FROM votes WHERE llm_id = $1',
          [llmId]
        );
        
        if (voteRows.length === 0) {
          // Create vote record
          await client.query(
            `INSERT INTO votes (llm_id, vote_count, positive_votes, negative_votes)
             VALUES ($1, $2, $3, $4)`,
            [
              llmId,
              voteType,
              voteType === 1 ? 1 : 0,
              voteType === -1 ? 1 : 0
            ]
          );
        } else {
          // Update vote counts
          let { vote_count, positive_votes, negative_votes } = voteRows[0];
          vote_count += voteChange;
          
          // Adjust positive/negative counts
          if (currentVote === 1) positive_votes--;
          if (currentVote === -1) negative_votes--;
          if (voteType === 1) positive_votes++;
          if (voteType === -1) negative_votes++;
          
          await client.query(
            `UPDATE votes 
             SET vote_count = $2, positive_votes = $3, negative_votes = $4, updated_at = NOW()
             WHERE llm_id = $1`,
            [llmId, vote_count, positive_votes, negative_votes]
          );
        }
        
        // Update user session activity
        await client.query(
          `UPDATE user_sessions 
           SET last_activity = NOW(), vote_count = vote_count + 1
           WHERE fingerprint = $1`,
          [fingerprint]
        );
        
        // Log analytics event
        await client.query(
          `INSERT INTO analytics (event_type, event_data, fingerprint, ip_address, user_agent)
           VALUES ($1, $2, $3, $4, $5)`,
          [
            'vote',
            JSON.stringify({ llmId, voteType, previousVote: currentVote }),
            fingerprint,
            metadata.ip || null,
            metadata.userAgent || null
          ]
        );
        
        // Invalidate cache
        await cacheManager.invalidateVoteCache(llmId);
        await cacheManager.setUserVote(fingerprint, llmId, voteType);
        
        // Get updated votes
        const votes = await this.getVotes();
        
        // Publish real-time update
        await cacheManager.publishVoteUpdate(llmId, {
          voteCount: votes[llmId],
          voteType,
          previousVote: currentVote
        });
        
        logger.business.voteSubmitted(fingerprint, llmId, voteType, currentVote);
        
        return {
          success: true,
          votes,
          userVote: voteType,
          previousVote: currentVote
        };
      });
    } catch (error) {
      logger.error('Vote transaction failed:', error);
      throw error;
    }
  }

  async getOrCreateUserSession(client, fingerprint, metadata) {
    const { rows } = await client.query(
      'SELECT * FROM user_sessions WHERE fingerprint = $1',
      [fingerprint]
    );
    
    if (rows.length === 0) {
      const { rows: newSession } = await client.query(
        `INSERT INTO user_sessions (fingerprint, ip_address, user_agent)
         VALUES ($1, $2, $3)
         RETURNING *`,
        [fingerprint, metadata.ip || null, metadata.userAgent || null]
      );
      return newSession[0];
    }
    
    return rows[0];
  }

  async getUserVotes(fingerprint) {
    await this.initialize();
    
    try {
      // Try cache first
      const cached = await cacheManager.getUserVotes(fingerprint);
      if (cached) return cached;
      
      // Fetch from database
      const { rows } = await dbManager.query(
        'SELECT llm_id, vote_type FROM user_votes WHERE fingerprint = $1',
        [fingerprint]
      );
      
      const votes = {};
      rows.forEach(row => {
        votes[row.llm_id] = row.vote_type;
      });
      
      // Cache the result
      await cacheManager.setAllUserVotes(fingerprint, votes);
      
      return votes;
    } catch (error) {
      logger.error('Failed to get user votes:', error);
      return {};
    }
  }

  async getVotes() {
    await this.initialize();
    
    try {
      // Try cache first
      const cached = await cacheManager.getAllVotes();
      if (cached) return cached;
      
      // Fetch from database
      const { rows } = await dbManager.query(`
        SELECT l.id, COALESCE(v.vote_count, 0) as count
        FROM llms l
        LEFT JOIN votes v ON l.id = v.llm_id
        ORDER BY l.id
      `);
      
      const votes = {};
      rows.forEach(row => {
        votes[row.id] = row.count;
      });
      
      // Cache the result
      await cacheManager.setAllVotes(votes);
      
      return votes;
    } catch (error) {
      logger.error('Failed to get votes:', error);
      
      // Fallback to empty votes
      const votes = {};
      const { llmData } = await import('./llm-data.js');
      llmData.forEach(llm => {
        votes[llm.id] = 0;
      });
      return votes;
    }
  }

  async getRankings() {
    await this.initialize();
    
    try {
      // Try cache first
      const cached = await cacheManager.getRankings();
      if (cached) return cached;
      
      // Fetch from database
      const { rows } = await dbManager.query(`
        SELECT 
          l.id,
          COALESCE(v.vote_count, 0) as count,
          RANK() OVER (ORDER BY COALESCE(v.vote_count, 0) DESC) as rank
        FROM llms l
        LEFT JOIN votes v ON l.id = v.llm_id
        ORDER BY count DESC, l.id
      `);
      
      const rankings = rows.map(row => ({
        id: row.id,
        count: parseInt(row.count),
        rank: parseInt(row.rank)
      }));
      
      // Cache the result
      await cacheManager.setRankings(rankings);
      
      return rankings;
    } catch (error) {
      logger.error('Failed to get rankings:', error);
      return [];
    }
  }

  async getStats() {
    await this.initialize();
    
    try {
      // Try cache first
      const cached = await cacheManager.getStats();
      if (cached) return cached;
      
      const now = new Date();
      const oneHourAgo = new Date(now - 60 * 60 * 1000);
      const todayStart = new Date(now.setHours(0, 0, 0, 0));
      
      // Get total votes
      const { rows: totalRows } = await dbManager.query(
        'SELECT COALESCE(SUM(ABS(vote_count)), 0) as total FROM votes'
      );
      
      // Get votes today
      const { rows: todayRows } = await dbManager.query(
        'SELECT COUNT(*) as count FROM user_votes WHERE created_at >= $1',
        [todayStart]
      );
      
      // Get votes last hour
      const { rows: hourRows } = await dbManager.query(
        'SELECT COUNT(*) as count FROM user_votes WHERE created_at >= $1',
        [oneHourAgo]
      );
      
      // Get trending models (most voted in last hour)
      const { rows: trendingRows } = await dbManager.query(`
        SELECT llm_id, COUNT(*) as recent_votes
        FROM user_votes
        WHERE created_at >= $1 AND vote_type != 0
        GROUP BY llm_id
        ORDER BY recent_votes DESC
        LIMIT 3
      `, [oneHourAgo]);
      
      // Get top model
      const { rows: topRows } = await dbManager.query(`
        SELECT llm_id
        FROM votes
        WHERE vote_count = (SELECT MAX(vote_count) FROM votes)
        LIMIT 1
      `);
      
      const stats = {
        totalVotes: parseInt(totalRows[0].total),
        votesToday: parseInt(todayRows[0].count),
        votesLastHour: parseInt(hourRows[0].count),
        trending: trendingRows.map(row => row.llm_id),
        topModel: topRows[0]?.llm_id || null
      };
      
      // Cache the result
      await cacheManager.setStats(stats);
      
      return stats;
    } catch (error) {
      logger.error('Failed to get stats:', error);
      return {
        totalVotes: 0,
        votesToday: 0,
        votesLastHour: 0,
        trending: [],
        topModel: null
      };
    }
  }

  async syncUserVotes(fingerprint) {
    await this.initialize();
    
    try {
      const userVotes = await this.getUserVotes(fingerprint);
      const allVotes = await this.getVotes();
      const rankings = await this.getRankings();
      const stats = await this.getStats();
      
      return {
        votes: allVotes,
        userVotes,
        rankings,
        stats
      };
    } catch (error) {
      logger.error('Failed to sync user votes:', error);
      throw error;
    }
  }

  async checkHealth() {
    try {
      const dbHealth = await dbManager.healthCheck();
      const cacheHealth = await cacheManager.healthCheck();
      
      return {
        database: dbHealth,
        cache: cacheHealth,
        status: dbHealth.postgres && cacheHealth.status === 'healthy' ? 'healthy' : 'degraded'
      };
    } catch (error) {
      return {
        status: 'unhealthy',
        error: error.message
      };
    }
  }
}

// Singleton instance
let voteManager;

export function getVoteManager() {
  if (!voteManager) {
    voteManager = new DatabaseVoteManager();
  }
  return voteManager;
}

export default getVoteManager();

// File: c:\Users\Taimoor\Documents\GitHub\llm-popularity-tracker\lib\vote-manager-wrapper.js
import config from './config.js';
import logger from './logger.js';

// This wrapper intelligently chooses between database and file-based vote manager
// based on configuration and availability

let voteManager;
let isUsingDatabase = false;

export async function getVoteManager() {
  if (voteManager) {
    return voteManager;
  }
  
  // Try to use database-backed manager if configured
  if (config.features.useDatabase) {
    try {
      const { getVoteManager: getDbVoteManager } = await import('./vote-manager-db.js');
      voteManager = getDbVoteManager();
      
      // Test the connection
      await voteManager.initialize();
      isUsingDatabase = true;
      
      logger.info('Using database-backed vote manager');
      return voteManager;
    } catch (error) {
      logger.warn('Failed to initialize database vote manager, falling back to file storage:', error.message);
    }
  }
  
  // Fall back to file-based manager
  try {
    const { getVoteManager: getFileVoteManager } = await import('./vote-manager.js');
    voteManager = getFileVoteManager();
    isUsingDatabase = false;
    
    logger.info('Using file-based vote manager');
    return voteManager;
  } catch (error) {
    logger.error('Failed to initialize any vote manager:', error);
    throw new Error('No vote manager available');
  }
}

// Adapter to make file-based manager async-compatible
export class VoteManagerAdapter {
  constructor(fileManager) {
    this.fileManager = fileManager;
  }
  
  async initialize() {
    // File manager doesn't need initialization
    return Promise.resolve();
  }
  
  async vote(fingerprint, llmId, voteType, metadata = {}) {
    try {
      const result = this.fileManager.vote(fingerprint, llmId, voteType);
      return Promise.resolve(result);
    } catch (error) {
      return Promise.reject(error);
    }
  }
  
  async getUserVotes(fingerprint) {
    try {
      const votes = this.fileManager.getUserVotes(fingerprint);
      return Promise.resolve(votes);
    } catch (error) {
      return Promise.reject(error);
    }
  }
  
  async getVotes() {
    try {
      const votes = this.fileManager.getVotes();
      return Promise.resolve(votes);
    } catch (error) {
      return Promise.reject(error);
    }
  }
  
  async getRankings() {
    try {
      const rankings = this.fileManager.getRankings();
      return Promise.resolve(rankings);
    } catch (error) {
      return Promise.reject(error);
    }
  }
  
  async getStats() {
    try {
      const stats = this.fileManager.getStats();
      return Promise.resolve(stats);
    } catch (error) {
      return Promise.reject(error);
    }
  }
  
  async syncUserVotes(fingerprint) {
    try {
      const userVotes = this.fileManager.getUserVotes(fingerprint);
      const votes = this.fileManager.getVotes();
      const rankings = this.fileManager.getRankings();
      const stats = this.fileManager.getStats();
      
      return Promise.resolve({
        votes,
        userVotes,
        rankings,
        stats
      });
    } catch (error) {
      return Promise.reject(error);
    }
  }
  
  async checkHealth() {
    return Promise.resolve({
      database: { postgres: false, redis: false },
      cache: { status: 'not-available' },
      status: 'healthy' // File-based is always healthy if accessible
    });
  }
}

// Wrapper function that returns the appropriate manager
export async function getAdaptedVoteManager() {
  const manager = await getVoteManager();
  
  // If it's the file-based manager, wrap it in the adapter
  if (!isUsingDatabase && manager.vote && !manager.vote.constructor.name.includes('Async')) {
    return new VoteManagerAdapter(manager);
  }
  
  return manager;
}

// Export status function
export function isUsingDatabaseStorage() {
  return isUsingDatabase;
}

// File: c:\Users\Taimoor\Documents\GitHub\llm-popularity-tracker\lib\vote-manager.js
import fs from 'fs';
import path from 'path';
import { llmData } from './llm-data.js';

class VoteManager {
  constructor() {
    this.votesFile = path.join(process.cwd(), 'data', 'votes.json');
    this.votes = {};
    this.userVotes = new Map(); // fingerprint -> { llmId -> vote (-1, 0, 1) }
    this.stats = {
      totalVotes: 0,
      lastHourVotes: [],
      dailyVotes: new Map(),
    };
    this.loadVotes();
  }

  loadVotes() {
    try {
      // Create data directory if it doesn't exist
      const dataDir = path.join(process.cwd(), 'data');
      if (!fs.existsSync(dataDir)) {
        fs.mkdirSync(dataDir, { recursive: true });
      }

      // Load votes from file if it exists
      if (fs.existsSync(this.votesFile)) {
        const data = JSON.parse(fs.readFileSync(this.votesFile, 'utf8'));
        this.votes = data.votes || {};
        // Load user votes from persistent storage
        if (data.userSessions) {
          this.userVotes = new Map(Object.entries(data.userSessions));
        }
        // Restore stats properly, converting arrays back to Maps
        if (data.stats) {
          this.stats.totalVotes = data.stats.totalVotes || 0;
          this.stats.lastHourVotes = data.stats.lastHourVotes || [];
          this.stats.dailyVotes = new Map(data.stats.dailyVotes || []);
        }
      } else {
        // Initialize with zero votes for all LLMs
        llmData.forEach(llm => {
          this.votes[llm.id] = 0;
        });
        this.saveVotes();
      }
    } catch (error) {
      console.error('Error loading votes:', error);
      // Initialize with empty votes
      llmData.forEach(llm => {
        this.votes[llm.id] = 0;
      });
    }
  }

  saveVotes() {
    try {
      const data = {
        votes: this.votes,
        userSessions: Object.fromEntries(this.userVotes.entries()),
        stats: {
          totalVotes: this.stats.totalVotes,
          lastHourVotes: this.stats.lastHourVotes.slice(-100), // Keep last 100 entries
          dailyVotes: Array.from(this.stats.dailyVotes.entries()).slice(-30), // Keep last 30 days
        },
        lastUpdated: new Date().toISOString(),
      };
      fs.writeFileSync(this.votesFile, JSON.stringify(data, null, 2));
    } catch (error) {
      console.error('Error saving votes:', error);
    }
  }

  vote(fingerprint, llmId, voteType) {
    // voteType: 1 for upvote, -1 for downvote, 0 for remove vote
    if (!this.votes.hasOwnProperty(llmId)) {
      return { success: false, error: 'Invalid LLM ID' };
    }

    // Get user's current votes
    let userVoteMap = this.userVotes.get(fingerprint) || {};
    const currentVote = userVoteMap[llmId] || 0;

    // Calculate vote change
    const voteChange = voteType - currentVote;
    
    if (voteChange === 0) {
      return { success: false, error: 'Vote unchanged' };
    }

    // Update vote count
    this.votes[llmId] += voteChange;
    
    // Update user's vote record
    if (voteType === 0) {
      delete userVoteMap[llmId];
    } else {
      userVoteMap[llmId] = voteType;
    }
    
    if (Object.keys(userVoteMap).length === 0) {
      this.userVotes.delete(fingerprint);
    } else {
      this.userVotes.set(fingerprint, userVoteMap);
    }

    // Update stats
    this.updateStats(llmId, voteType);
    
    // Save immediately to ensure persistence
    this.saveVotes();

    return { 
      success: true, 
      votes: this.votes,
      userVote: voteType,
      previousVote: currentVote,
    };
  }

  updateStats(llmId, voteType) {
    const now = new Date();
    
    // Update total votes
    if (voteType !== 0) {
      this.stats.totalVotes++;
    }
    
    // Track last hour votes
    this.stats.lastHourVotes.push({
      llmId,
      voteType,
      timestamp: now.toISOString(),
    });
    
    // Remove votes older than 1 hour
    const oneHourAgo = new Date(now - 60 * 60 * 1000);
    this.stats.lastHourVotes = this.stats.lastHourVotes.filter(
      v => new Date(v.timestamp) > oneHourAgo
    );
    
    // Track daily votes
    const today = now.toDateString();
    const dailyCount = this.stats.dailyVotes.get(today) || 0;
    this.stats.dailyVotes.set(today, dailyCount + 1);
  }

  getUserVotes(fingerprint) {
    return this.userVotes.get(fingerprint) || {};
  }

  getVotes() {
    return this.votes;
  }

  getRankings() {
    const rankings = Object.entries(this.votes)
      .map(([id, count]) => ({ id, count }))
      .sort((a, b) => b.count - a.count)
      .map((item, index) => ({ ...item, rank: index + 1 }));
    
    return rankings;
  }

  getStats() {
    const now = new Date();
    const oneHourAgo = new Date(now - 60 * 60 * 1000);
    const today = now.toDateString();
    
    // Get trending (most voted in last hour)
    const recentVotes = {};
    this.stats.lastHourVotes.forEach(v => {
      if (new Date(v.timestamp) > oneHourAgo && v.voteType !== 0) {
        recentVotes[v.llmId] = (recentVotes[v.llmId] || 0) + 1;
      }
    });
    
    const trending = Object.entries(recentVotes)
      .sort((a, b) => b[1] - a[1])
      .slice(0, 3)
      .map(([id]) => id);
    
    return {
      totalVotes: this.stats.totalVotes,
      votesToday: this.stats.dailyVotes.get(today) || 0,
      votesLastHour: this.stats.lastHourVotes.filter(
        v => new Date(v.timestamp) > oneHourAgo
      ).length,
      trending,
      topModel: this.getRankings()[0]?.id || null,
    };
  }
}

// Singleton instance
let voteManager;

export function getVoteManager() {
  if (!voteManager) {
    voteManager = new VoteManager();
  }
  return voteManager;
}

// File: c:\Users\Taimoor\Documents\GitHub\llm-popularity-tracker\scripts\migrate.js
import dbManager from '../lib/database.js';
import logger from '../lib/logger.js';

const migrations = [
  {
    name: '001_create_llms_table',
    up: `
      CREATE TABLE IF NOT EXISTS llms (
        id VARCHAR(255) PRIMARY KEY,
        name VARCHAR(255) NOT NULL,
        company VARCHAR(255) NOT NULL,
        description TEXT,
        use_cases JSONB DEFAULT '[]',
        release_year INTEGER,
        color VARCHAR(100),
        logo VARCHAR(10),
        image_url VARCHAR(500),
        created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
        updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
      );
      
      -- Create index for faster queries
      CREATE INDEX IF NOT EXISTS idx_llms_company ON llms(company);
      CREATE INDEX IF NOT EXISTS idx_llms_release_year ON llms(release_year);
    `,
    down: `
      DROP INDEX IF EXISTS idx_llms_release_year;
      DROP INDEX IF EXISTS idx_llms_company;
      DROP TABLE IF EXISTS llms;
    `
  },
  
  {
    name: '002_create_votes_table',
    up: `
      CREATE TABLE IF NOT EXISTS votes (
        id SERIAL PRIMARY KEY,
        llm_id VARCHAR(255) NOT NULL REFERENCES llms(id) ON DELETE CASCADE,
        vote_count INTEGER DEFAULT 0,
        positive_votes INTEGER DEFAULT 0,
        negative_votes INTEGER DEFAULT 0,
        created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
        updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
        UNIQUE(llm_id)
      );
      
      -- Create indexes for performance
      CREATE INDEX IF NOT EXISTS idx_votes_llm_id ON votes(llm_id);
      CREATE INDEX IF NOT EXISTS idx_votes_vote_count ON votes(vote_count DESC);
    `,
    down: `
      DROP INDEX IF EXISTS idx_votes_vote_count;
      DROP INDEX IF EXISTS idx_votes_llm_id;
      DROP TABLE IF EXISTS votes;
    `
  },
  
  {
    name: '003_create_user_sessions_table',
    up: `
      CREATE TABLE IF NOT EXISTS user_sessions (
        id SERIAL PRIMARY KEY,
        fingerprint VARCHAR(255) NOT NULL,
        ip_address INET,
        user_agent TEXT,
        country VARCHAR(2),
        created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
        last_activity TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
        is_suspicious BOOLEAN DEFAULT FALSE,
        vote_count INTEGER DEFAULT 0,
        UNIQUE(fingerprint)
      );
      
      -- Create indexes
      CREATE INDEX IF NOT EXISTS idx_user_sessions_fingerprint ON user_sessions(fingerprint);
      CREATE INDEX IF NOT EXISTS idx_user_sessions_last_activity ON user_sessions(last_activity);
      CREATE INDEX IF NOT EXISTS idx_user_sessions_suspicious ON user_sessions(is_suspicious);
      CREATE INDEX IF NOT EXISTS idx_user_sessions_ip ON user_sessions(ip_address);
    `,
    down: `
      DROP INDEX IF EXISTS idx_user_sessions_ip;
      DROP INDEX IF EXISTS idx_user_sessions_suspicious;
      DROP INDEX IF EXISTS idx_user_sessions_last_activity;
      DROP INDEX IF EXISTS idx_user_sessions_fingerprint;
      DROP TABLE IF EXISTS user_sessions;
    `
  },
  
  {
    name: '004_create_user_votes_table',
    up: `
      CREATE TABLE IF NOT EXISTS user_votes (
        id SERIAL PRIMARY KEY,
        fingerprint VARCHAR(255) NOT NULL,
        llm_id VARCHAR(255) NOT NULL REFERENCES llms(id) ON DELETE CASCADE,
        vote_type INTEGER NOT NULL CHECK (vote_type IN (-1, 0, 1)),
        previous_vote INTEGER DEFAULT 0,
        created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
        updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
        ip_address INET,
        user_agent TEXT,
        UNIQUE(fingerprint, llm_id)
      );
      
      -- Create indexes for performance
      CREATE INDEX IF NOT EXISTS idx_user_votes_fingerprint ON user_votes(fingerprint);
      CREATE INDEX IF NOT EXISTS idx_user_votes_llm_id ON user_votes(llm_id);
      CREATE INDEX IF NOT EXISTS idx_user_votes_created_at ON user_votes(created_at DESC);
      CREATE INDEX IF NOT EXISTS idx_user_votes_vote_type ON user_votes(vote_type);
    `,
    down: `
      DROP INDEX IF EXISTS idx_user_votes_vote_type;
      DROP INDEX IF EXISTS idx_user_votes_created_at;
      DROP INDEX IF EXISTS idx_user_votes_llm_id;
      DROP INDEX IF EXISTS idx_user_votes_fingerprint;
      DROP TABLE IF EXISTS user_votes;
    `
  },
  
  {
    name: '005_create_analytics_table',
    up: `
      CREATE TABLE IF NOT EXISTS analytics (
        id SERIAL PRIMARY KEY,
        event_type VARCHAR(100) NOT NULL,
        event_data JSONB NOT NULL DEFAULT '{}',
        fingerprint VARCHAR(255),
        ip_address INET,
        user_agent TEXT,
        created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
      );
      
      -- Create indexes for analytics queries
      CREATE INDEX IF NOT EXISTS idx_analytics_event_type ON analytics(event_type);
      CREATE INDEX IF NOT EXISTS idx_analytics_created_at ON analytics(created_at DESC);
      CREATE INDEX IF NOT EXISTS idx_analytics_fingerprint ON analytics(fingerprint);
    `,
    down: `
      DROP INDEX IF EXISTS idx_analytics_fingerprint;
      DROP INDEX IF EXISTS idx_analytics_created_at;
      DROP INDEX IF EXISTS idx_analytics_event_type;
      DROP TABLE IF EXISTS analytics;
    `
  },
  
  {
    name: '006_create_rate_limits_table',
    up: `
      CREATE TABLE IF NOT EXISTS rate_limits (
        id SERIAL PRIMARY KEY,
        key VARCHAR(255) NOT NULL,
        points INTEGER DEFAULT 0,
        expire_at TIMESTAMP WITH TIME ZONE,
        created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
        UNIQUE(key)
      );
      
      -- Create indexes
      CREATE INDEX IF NOT EXISTS idx_rate_limits_key ON rate_limits(key);
      CREATE INDEX IF NOT EXISTS idx_rate_limits_expire_at ON rate_limits(expire_at);
    `,
    down: `
      DROP INDEX IF EXISTS idx_rate_limits_expire_at;
      DROP INDEX IF EXISTS idx_rate_limits_key;
      DROP TABLE IF EXISTS rate_limits;
    `
  },
  
  {
    name: '007_create_triggers',
    up: `
      -- Create function to update timestamp
      CREATE OR REPLACE FUNCTION update_updated_at_column()
      RETURNS TRIGGER AS $$
      BEGIN
          NEW.updated_at = NOW();
          RETURN NEW;
      END;
      $$ language 'plpgsql';
      
      -- Create triggers for updated_at
      CREATE TRIGGER update_llms_updated_at BEFORE UPDATE ON llms 
        FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
        
      CREATE TRIGGER update_votes_updated_at BEFORE UPDATE ON votes 
        FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
        
      CREATE TRIGGER update_user_votes_updated_at BEFORE UPDATE ON user_votes 
        FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
    `,
    down: `
      DROP TRIGGER IF EXISTS update_user_votes_updated_at ON user_votes;
      DROP TRIGGER IF EXISTS update_votes_updated_at ON votes;
      DROP TRIGGER IF EXISTS update_llms_updated_at ON llms;
      DROP FUNCTION IF EXISTS update_updated_at_column();
    `
  }
];

async function runMigrations() {
  try {
    await dbManager.initialize();
    
    // Create migrations table
    await dbManager.query(`
      CREATE TABLE IF NOT EXISTS migrations (
        id SERIAL PRIMARY KEY,
        name VARCHAR(255) NOT NULL UNIQUE,
        executed_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
      );
    `);
    
    // Get already executed migrations
    const { rows: executedMigrations } = await dbManager.query(
      'SELECT name FROM migrations ORDER BY id'
    );
    
    const executedNames = executedMigrations.map(row => row.name);
    
    // Run pending migrations
    for (const migration of migrations) {
      if (!executedNames.includes(migration.name)) {
        logger.info(`Running migration: ${migration.name}`);
        
        await dbManager.transaction(async (client) => {
          await client.query(migration.up);
          await client.query(
            'INSERT INTO migrations (name) VALUES ($1)',
            [migration.name]
          );
        });
        
        logger.info(`Migration completed: ${migration.name}`);
      } else {
        logger.info(`Migration already executed: ${migration.name}`);
      }
    }
    
    logger.info('All migrations completed successfully');
  } catch (error) {
    logger.error('Migration failed:', error);
    process.exit(1);
  } finally {
    await dbManager.closeAll();
  }
}

// Run migrations if called directly
if (import.meta.url === `file://${process.argv[1]}`) {
  runMigrations();
}

export { runMigrations, migrations };

// File: c:\Users\Taimoor\Documents\GitHub\llm-popularity-tracker\scripts\reset.js
import dbManager from '../lib/database.js';
import cacheManager from '../lib/cache.js';
import logger from '../lib/logger.js';
import { migrations } from './migrate.js';
import { seedDatabase } from './seed.js';

async function resetDatabase() {
  try {
    await dbManager.initialize();
    logger.warn('⚠️  Database reset initiated - ALL DATA WILL BE LOST!');
    
    // Drop all tables in reverse order to respect foreign keys
    logger.info('Dropping all tables...');
    
    await dbManager.transaction(async (client) => {
      // First, get all custom tables (excluding system tables)
      const { rows: tables } = await client.query(`
        SELECT tablename FROM pg_tables 
        WHERE schemaname = 'public' 
        ORDER BY tablename DESC
      `);
      
      // Drop all tables
      for (const { tablename } of tables) {
        logger.info(`Dropping table: ${tablename}`);
        await client.query(`DROP TABLE IF EXISTS ${tablename} CASCADE`);
      }
      
      // Drop all functions
      await client.query(`DROP FUNCTION IF EXISTS update_updated_at_column() CASCADE`);
    });
    
    logger.info('All tables dropped successfully');
    
    // Clear Redis cache if available
    try {
      await cacheManager.initialize();
      logger.info('Clearing Redis cache...');
      await cacheManager.invalidateAllCaches();
      logger.info('Redis cache cleared');
    } catch (error) {
      logger.warn('Could not clear Redis cache:', error.message);
    }
    
    // Re-run all migrations
    logger.info('Re-creating database schema...');
    
    // Create migrations table
    await dbManager.query(`
      CREATE TABLE IF NOT EXISTS migrations (
        id SERIAL PRIMARY KEY,
        name VARCHAR(255) NOT NULL UNIQUE,
        executed_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
      );
    `);
    
    // Run all migrations
    for (const migration of migrations) {
      logger.info(`Running migration: ${migration.name}`);
      await dbManager.transaction(async (client) => {
        await client.query(migration.up);
        await client.query(
          'INSERT INTO migrations (name) VALUES ($1)',
          [migration.name]
        );
      });
    }
    
    logger.info('Database schema recreated successfully');
    
    // Optionally seed the database
    const shouldSeed = process.argv.includes('--seed');
    if (shouldSeed) {
      logger.info('Seeding database with initial data...');
      await seedDatabase();
    } else {
      logger.info('Skipping database seeding (use --seed flag to seed)');
    }
    
    logger.info('✅ Database reset completed successfully');
    
  } catch (error) {
    logger.error('Database reset failed:', error);
    process.exit(1);
  } finally {
    await dbManager.closeAll();
  }
}

// Run reset if called directly
if (import.meta.url === `file://${process.argv[1]}`) {
  // Safety check for production
  if (process.env.NODE_ENV === 'production' && !process.argv.includes('--force')) {
    logger.error('❌ Cannot reset production database without --force flag');
    logger.error('This action will DELETE ALL DATA. Use: npm run db:reset -- --force');
    process.exit(1);
  }
  
  resetDatabase();
}

export { resetDatabase };

// File: c:\Users\Taimoor\Documents\GitHub\llm-popularity-tracker\scripts\seed.js
import dbManager from '../lib/database.js';
import { llmData } from '../lib/llm-data.js';
import logger from '../lib/logger.js';

async function seedDatabase() {
  try {
    await dbManager.initialize();
    logger.info('Starting database seeding...');
    
    // Begin transaction
    await dbManager.transaction(async (client) => {
      // Insert LLMs
      logger.info('Inserting LLMs...');
      for (const llm of llmData) {
        await client.query(
          `INSERT INTO llms (
            id, name, company, description, use_cases, 
            release_year, color, logo, image_url
          ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
          ON CONFLICT (id) DO UPDATE SET
            name = EXCLUDED.name,
            company = EXCLUDED.company,
            description = EXCLUDED.description,
            use_cases = EXCLUDED.use_cases,
            release_year = EXCLUDED.release_year,
            color = EXCLUDED.color,
            logo = EXCLUDED.logo,
            image_url = EXCLUDED.image_url,
            updated_at = NOW()`,
          [
            llm.id,
            llm.name,
            llm.company,
            llm.description,
            JSON.stringify(llm.useCases || []),
            llm.releaseYear,
            llm.color,
            llm.logo,
            llm.image || null
          ]
        );
      }
      logger.info(`Inserted ${llmData.length} LLMs`);
      
      // Initialize vote counts for each LLM
      logger.info('Initializing vote counts...');
      for (const llm of llmData) {
        await client.query(
          `INSERT INTO votes (llm_id, vote_count, positive_votes, negative_votes)
           VALUES ($1, 0, 0, 0)
           ON CONFLICT (llm_id) DO NOTHING`,
          [llm.id]
        );
      }
      logger.info('Vote counts initialized');
      
      // Insert sample analytics events (optional)
      logger.info('Inserting sample analytics events...');
      const sampleEvents = [
        { event_type: 'page_view', event_data: { page: 'home' } },
        { event_type: 'app_start', event_data: { version: '0.1.0' } },
      ];
      
      for (const event of sampleEvents) {
        await client.query(
          `INSERT INTO analytics (event_type, event_data)
           VALUES ($1, $2)`,
          [event.event_type, JSON.stringify(event.event_data)]
        );
      }
      logger.info('Sample analytics events inserted');
    });
    
    // Verify seed data
    const { rows: llmCount } = await dbManager.query('SELECT COUNT(*) FROM llms');
    const { rows: voteCount } = await dbManager.query('SELECT COUNT(*) FROM votes');
    
    logger.info('Database seeding completed successfully');
    logger.info(`Total LLMs: ${llmCount[0].count}`);
    logger.info(`Total vote records: ${voteCount[0].count}`);
    
  } catch (error) {
    logger.error('Database seeding failed:', error);
    process.exit(1);
  } finally {
    await dbManager.closeAll();
  }
}

// Run seed if called directly
if (import.meta.url === `file://${process.argv[1]}`) {
  seedDatabase();
}

export { seedDatabase };

// File: c:\Users\Taimoor\Documents\GitHub\llm-popularity-tracker\store\useVoteStore.js
import { create } from 'zustand';
import axios from 'axios';
import { llmData } from '@/lib/llm-data';
import fingerprintService from '@/lib/fingerprint';

const useVoteStore = create((set, get) => ({
  llms: llmData,
  votes: {},
  userVotes: {},
  rankings: [],
  stats: {
    totalVotes: 0,
    votesToday: 0,
    votesLastHour: 0,
    trending: [],
    topModel: null,
  },
  loading: false,
  error: null,
  lastUpdate: null,
  fingerprint: null,
  
  // Initialize votes and fingerprint
  initializeVotes: async () => {
    set({ loading: true, error: null });
    try {
      // Get fingerprint first
      const fingerprint = await fingerprintService.getFingerprintWithFallbacks();
      set({ fingerprint });
      
      // Load votes from localStorage first for immediate UI update
      const localVotes = get().loadVotesFromLocalStorage();
      if (localVotes.userVotes && Object.keys(localVotes.userVotes).length > 0) {
        set({ userVotes: localVotes.userVotes });
      }
      
      // Then sync with server
      const response = await axios.post('/api/vote/sync', { fingerprint });
      const serverData = {
        votes: response.data.votes || {},
        userVotes: response.data.userVotes || {},
        rankings: response.data.rankings || [],
        stats: response.data.stats || get().stats,
        loading: false,
        lastUpdate: new Date(),
      };
      
      set(serverData);
      
      // Update rankings and stats after loading
      get().updateRankings();
      
      // Save to localStorage
      get().saveVotesToLocalStorage(serverData);
      
    } catch (error) {
      console.error('Failed to load votes:', error);
      
      // Try to load from localStorage as fallback
      const localData = get().loadVotesFromLocalStorage();
      if (localData.votes) {
        set({ 
          ...localData,
          loading: false, 
          error: 'Using offline data',
        });
      } else {
        set({ 
          loading: false, 
          error: 'Failed to load votes',
        });
        // Initialize with zero votes
        const initialVotes = {};
        llmData.forEach(llm => {
          initialVotes[llm.id] = 0;
        });
        set({ votes: initialVotes });
      }
    }
  },
  
  // Vote for an LLM
  vote: async (llmId, voteType) => {
    const currentUserVote = get().userVotes[llmId] || 0;
    const fingerprint = get().fingerprint;
    
    if (!fingerprint) {
      console.error('No fingerprint available');
      return;
    }
    
    // Optimistically update UI
    const optimisticVotes = { ...get().votes };
    const optimisticUserVotes = { ...get().userVotes };
    
    // Calculate vote change
    const voteChange = voteType - currentUserVote;
    optimisticVotes[llmId] = (optimisticVotes[llmId] || 0) + voteChange;
    
    if (voteType === 0) {
      delete optimisticUserVotes[llmId];
    } else {
      optimisticUserVotes[llmId] = voteType;
    }
    
    const newState = { 
      votes: optimisticVotes,
      userVotes: optimisticUserVotes,
    };
    
    set(newState);
    
    // Save to localStorage immediately
    get().saveVotesToLocalStorage(newState);
    
    try {
      const response = await axios.post('/api/vote', { 
        fingerprint, 
        llmId, 
        voteType 
      });
      
      if (response.data.success) {
        const serverState = {
          votes: response.data.votes,
          userVotes: { ...get().userVotes, [llmId]: response.data.userVote },
          lastUpdate: new Date(),
        };
        
        set(serverState);
        
        // Update rankings and stats
        get().updateRankings();
        
        // Save updated state to localStorage
        get().saveVotesToLocalStorage(serverState);
      }
    } catch (error) {
      console.error('Vote failed:', error);
      
      // Don't revert - keep the optimistic update as it's saved locally
      // Update rankings even if server sync fails
      get().updateRankings();
      
      set({ 
        error: 'Failed to sync vote with server',
      });
      
      // Clear error after 3 seconds
      setTimeout(() => set({ error: null }), 3000);
    }
  },
  
  // Update rankings based on votes
  updateRankings: () => {
    const votes = get().votes;
    const rankings = Object.entries(votes)
      .map(([id, count]) => ({ id, count }))
      .sort((a, b) => b.count - a.count)
      .map((item, index) => ({ ...item, rank: index + 1 }));
    
    // Calculate stats in real-time
    const totalVotes = Object.values(votes).reduce((sum, count) => sum + Math.abs(count), 0);
    const topModel = rankings[0]?.id || null;
    const topModelName = topModel ? get().getLLMById(topModel)?.name || topModel : null;
    
    const updatedStats = {
      ...get().stats,
      totalVotes,
      votesToday: totalVotes, // For now, treat all votes as today's votes
      votesLastHour: totalVotes, // For now, treat all votes as last hour's votes  
      topModel: topModelName,
    };
    
    set({ rankings, stats: updatedStats });
  },
  
  // Fetch latest stats
  fetchStats: async () => {
    try {
      const response = await axios.get('/api/stats');
      set({
        stats: response.data.stats,
        rankings: response.data.rankings,
        lastUpdate: new Date(),
      });
    } catch (error) {
      console.error('Failed to fetch stats:', error);
    }
  },
  
  // Get LLM by ID
  getLLMById: (id) => {
    return get().llms.find(llm => llm.id === id);
  },
  
  // Get user's vote for an LLM
  getUserVote: (llmId) => {
    return get().userVotes[llmId] || 0;
  },
  
  // Get total votes for an LLM
  getVoteCount: (llmId) => {
    return get().votes[llmId] || 0;
  },
  
  // Check if LLM is trending
  isTrending: (llmId) => {
    return get().stats.trending.includes(llmId);
  },
  
  // Get rank position for an LLM
  getRank: (llmId) => {
    const ranking = get().rankings.find(r => r.id === llmId);
    return ranking ? ranking.rank : null;
  },
  
  // Save votes to localStorage
  saveVotesToLocalStorage: (state) => {
    if (typeof window === 'undefined') return;
    
    try {
      const dataToSave = {
        votes: state.votes || get().votes,
        userVotes: state.userVotes || get().userVotes,
        lastUpdate: state.lastUpdate || get().lastUpdate,
        timestamp: new Date().toISOString(),
      };
      
      localStorage.setItem('llm-tracker-votes', JSON.stringify(dataToSave));
      sessionStorage.setItem('llm-tracker-votes-backup', JSON.stringify(dataToSave));
      
      // Also save with fingerprint as key for additional persistence
      const fingerprint = get().fingerprint;
      if (fingerprint) {
        localStorage.setItem(`llm-tracker-votes-${fingerprint}`, JSON.stringify(dataToSave));
      }
    } catch (error) {
      console.error('Failed to save votes to localStorage:', error);
    }
  },
  
  // Load votes from localStorage
  loadVotesFromLocalStorage: () => {
    if (typeof window === 'undefined') return {};
    
    try {
      // Try primary storage first
      let stored = localStorage.getItem('llm-tracker-votes');
      
      if (!stored) {
        // Try sessionStorage backup
        stored = sessionStorage.getItem('llm-tracker-votes-backup');
      }
      
      if (!stored) {
        // Try fingerprint-based storage
        const fingerprint = get().fingerprint;
        if (fingerprint) {
          stored = localStorage.getItem(`llm-tracker-votes-${fingerprint}`);
        }
      }
      
      if (stored) {
        const data = JSON.parse(stored);
        return {
          votes: data.votes || {},
          userVotes: data.userVotes || {},
          lastUpdate: data.lastUpdate ? new Date(data.lastUpdate) : null,
        };
      }
    } catch (error) {
      console.error('Failed to load votes from localStorage:', error);
    }
    
    return {};
  },
  
  // Clear all stored data (for testing or user request)
  clearAllStoredData: () => {
    if (typeof window === 'undefined') return;
    
    try {
      localStorage.removeItem('llm-tracker-votes');
      sessionStorage.removeItem('llm-tracker-votes-backup');
      
      // Clear fingerprint-based storage
      const fingerprint = get().fingerprint;
      if (fingerprint) {
        localStorage.removeItem(`llm-tracker-votes-${fingerprint}`);
      }
      
      // Clear fingerprint
      fingerprintService.clearFingerprint();
      
      // Reset state
      const initialVotes = {};
      llmData.forEach(llm => {
        initialVotes[llm.id] = 0;
      });
      
      set({
        votes: initialVotes,
        userVotes: {},
        fingerprint: null,
      });
    } catch (error) {
      console.error('Failed to clear stored data:', error);
    }
  },
}));

export default useVoteStore;

