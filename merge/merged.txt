// File: c:\Users\Taimoor\Documents\GitHub\llm-popularity-tracker\app\api\health\route.js
import { NextResponse } from 'next/server';
import { supabase } from '@/lib/supabase/client';

export async function GET() {
  try {
    // Test Supabase connection
    const { data, error } = await supabase
      .from('llms')
      .select('count')
      .limit(1);

    const healthy = !error;

    return NextResponse.json({
      status: healthy ? 'healthy' : 'unhealthy',
      service: 'llm-popularity-tracker',
      timestamp: new Date().toISOString(),
      supabase: {
        connected: healthy,
        error: error?.message
      }
    }, {
      status: healthy ? 200 : 503
    });
  } catch (error) {
    return NextResponse.json({
      status: 'error',
      service: 'llm-popularity-tracker',
      timestamp: new Date().toISOString(),
      error: error.message
    }, {
      status: 503
    });
  }
}

// File: c:\Users\Taimoor\Documents\GitHub\llm-popularity-tracker\app\globals.css
@tailwind base;
@tailwind components;
@tailwind utilities;

@layer base {
  :root {
    --background: #0a0a0a;
    --foreground: #ededed;
  }

  html {
    -webkit-tap-highlight-color: transparent;
    touch-action: manipulation;
    scroll-behavior: smooth;
  }

  body {
    @apply bg-background text-foreground;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
  }

  * {
    @apply border-border;
    -webkit-tap-highlight-color: transparent;
  }

  /* Touch optimizations for mobile */
  button, [role="button"], input, select {
    touch-action: manipulation;
  }

  /* Prevent zoom on input focus on iOS Safari */
  @media screen and (max-width: 767px) {
    input[type="text"], 
    input[type="search"], 
    select {
      font-size: 16px;
    }
  }
  
  /* Typography System */
  .font-inter {
    font-family: var(--font-inter), system-ui, -apple-system, sans-serif;
  }
  
  .font-sora {
    font-family: var(--font-sora), system-ui, -apple-system, sans-serif;
  }
  
  .font-mono {
    font-family: var(--font-mono), 'Courier New', monospace;
  }
  
  /* Heading styles with lighter weights */
  h1 {
    @apply font-sora font-light tracking-tight;
  }
  
  h2 {
    @apply font-sora font-normal tracking-tight;
  }
  
  h3 {
    @apply font-inter font-medium;
  }
  
  p, span, div {
    @apply font-inter font-light;
  }
}

@layer utilities {
  .text-gradient {
    @apply bg-gradient-to-r from-primary via-accent to-success bg-clip-text text-transparent;
  }

  .glow {
    @apply shadow-lg shadow-primary/20;
  }

  .card-glow {
    @apply hover:shadow-xl hover:shadow-primary/10 transition-shadow duration-300;
  }

  .scrollbar-thin {
    scrollbar-width: thin;
    scrollbar-color: #4b5563 #1f2937;
  }

  .scrollbar-thin::-webkit-scrollbar {
    width: 8px;
    height: 8px;
  }

  .scrollbar-thin::-webkit-scrollbar-track {
    @apply bg-gray-800 rounded-full;
  }

  .scrollbar-thin::-webkit-scrollbar-thumb {
    @apply bg-gray-600 rounded-full hover:bg-gray-500;
  }
}

// File: c:\Users\Taimoor\Documents\GitHub\llm-popularity-tracker\app\layout.js
import { Inter, Sora, JetBrains_Mono } from "next/font/google";
import { Analytics } from '@vercel/analytics/react';
import { SpeedInsights } from '@vercel/speed-insights/next';
import "./globals.css";

const inter = Inter({
  variable: "--font-inter",
  subsets: ["latin"],
  display: 'swap',
});

const sora = Sora({
  variable: "--font-sora",
  subsets: ["latin"],
  display: 'swap',
});

const jetbrainsMono = JetBrains_Mono({
  variable: "--font-mono",
  subsets: ["latin"],
  display: 'swap',
});

export const metadata = {
  title: "LLM Popularity Tracker 2025 | Vote for the Best AI Models",
  description: "Vote for your favorite Large Language Models and see real-time community rankings. Compare GPT-4o, Claude 3.5, Gemini Ultra, Llama 3 and more AI models in 2025.",
  keywords: "LLM, Large Language Models, AI voting, GPT-4, Claude, Gemini, artificial intelligence, AI comparison, machine learning, 2025",
  authors: [{ name: "AI Community" }],
  creator: "AI Community",
  publisher: "LLM Popularity Tracker",
  robots: {
    index: true,
    follow: true,
  },
  openGraph: {
    type: "website",
    locale: "en_US",
    url: "https://llm-popularity-tracker.vercel.app",
    title: "LLM Popularity Tracker 2025 | Vote for the Best AI Models",
    description: "Vote for your favorite Large Language Models and see real-time community rankings. Compare GPT-4o, Claude 3.5, Gemini Ultra, Llama 3 and more AI models.",
    siteName: "LLM Popularity Tracker",
  },
  twitter: {
    card: "summary_large_image",
    title: "LLM Popularity Tracker 2025",
    description: "Vote for your favorite Large Language Models and see real-time community rankings.",
  },
  viewport: {
    width: "device-width",
    initialScale: 1,
    maximumScale: 1,
  },
  themeColor: "#7c3aed",
  colorScheme: "dark",
};

export default function RootLayout({ children }) {
  const structuredData = {
    "@context": "https://schema.org",
    "@type": "WebApplication",
    "name": "LLM Popularity Tracker 2025",
    "description": "Vote for your favorite Large Language Models and see real-time community rankings",
    "url": "https://llm-popularity-tracker.vercel.app",
    "applicationCategory": "Utility",
    "operatingSystem": "Any",
    "offers": {
      "@type": "Offer",
      "price": "0",
      "priceCurrency": "USD"
    },
    "author": {
      "@type": "Organization",
      "name": "AI Community"
    }
  }

  return (
    <html lang="en" className="dark">
      <head>
        <script
          type="application/ld+json"
          dangerouslySetInnerHTML={{
            __html: JSON.stringify(structuredData),
          }}
        />
      </head>
      <body
        className={`${inter.variable} ${sora.variable} ${jetbrainsMono.variable} antialiased bg-background text-foreground font-inter`}
      >
        {children}
        <Analytics />
        <SpeedInsights />
      </body>
    </html>
  );
}


// File: c:\Users\Taimoor\Documents\GitHub\llm-popularity-tracker\app\page.js
'use client';

import { useEffect, useState } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { Search, Wifi, WifiOff } from 'lucide-react';
import { Toaster, toast } from 'sonner';
import Header from '@/components/Header';
import LLMCard from '@/components/LLMCard';
import StatsPanel from '@/components/StatsPanel';
import VoteChart from '@/components/VoteChart';
import ErrorBoundary from '@/components/ErrorBoundary';
import useVoteStore from '@/store/useVoteStore';

export default function Home() {
  const [searchTerm, setSearchTerm] = useState('');
  const [sortBy, setSortBy] = useState('votes'); // votes, name, company
  
  const { 
    llms, 
    initializeVotes, 
    loading,
    realtimeConnected,
    cleanup,
    error
  } = useVoteStore();
  
  useEffect(() => {
    // Initialize Supabase connection
    initializeVotes();
    
    // Show connection status
    const timer = setTimeout(() => {
      if (realtimeConnected) {
        toast.success('Connected to real-time updates', {
          icon: <Wifi className="w-4 h-4" />,
          duration: 2000
        });
      }
    }, 2000);
    
    // Cleanup on unmount
    return () => {
      clearTimeout(timer);
      cleanup();
    };
  }, []);
  
  // Show error toast if there's an error
  useEffect(() => {
    if (error) {
      toast.error(error);
    }
  }, [error]);
  
  // Filter and sort LLMs
  const filteredLLMs = llms
    .filter(llm => 
      llm.name.toLowerCase().includes(searchTerm.toLowerCase()) ||
      llm.company.toLowerCase().includes(searchTerm.toLowerCase())
    );
  
  const sortedLLMs = [...filteredLLMs].sort((a, b) => {
    const store = useVoteStore.getState();
    
    if (sortBy === 'votes') {
      const aVotes = store.getVoteCount(a.id);
      const bVotes = store.getVoteCount(b.id);
      return bVotes - aVotes;
    } else if (sortBy === 'name') {
      return a.name.localeCompare(b.name);
    } else if (sortBy === 'company') {
      return a.company.localeCompare(b.company);
    }
    return 0;
  });
  
  return (
    <div className="min-h-screen bg-background">
      <Toaster position="bottom-right" theme="dark" />
      <Header />
      
      {/* Real-time Connection Indicator - Mobile Optimized */}
      <div className="fixed top-2 right-2 sm:top-4 sm:right-4 z-50">
        <motion.div
          initial={{ opacity: 0, scale: 0.8 }}
          animate={{ opacity: 1, scale: 1 }}
          className={`flex items-center gap-1 sm:gap-2 px-2 sm:px-3 py-1 sm:py-1.5 rounded-full text-xs font-medium backdrop-blur-sm border ${
            realtimeConnected 
              ? 'bg-green-500/10 border-green-500/30 text-green-400' 
              : 'bg-yellow-500/10 border-yellow-500/30 text-yellow-400'
          }`}
        >
          {realtimeConnected ? (
            <>
              <Wifi className="w-3 h-3" />
              <span className="hidden sm:inline">Live</span>
              <span className="w-2 h-2 bg-green-400 rounded-full animate-pulse" />
            </>
          ) : (
            <>
              <WifiOff className="w-3 h-3" />
              <span className="hidden sm:inline">Connecting...</span>
            </>
          )}
        </motion.div>
      </div>
      
      <main className="container mx-auto px-3 sm:px-4 py-4 sm:py-6 md:py-8">
        {/* Hero Section - Mobile Optimized */}
        <motion.div
          initial={{ opacity: 0, y: 20 }}
          animate={{ opacity: 1, y: 0 }}
          className="text-center mb-4 sm:mb-6 px-2"
        >
          <h2 className="text-xl sm:text-2xl md:text-3xl font-light text-foreground mb-2 sm:mb-3 font-sora leading-tight">
            Which LLM Rules in 2025?
          </h2>
          <p className="text-muted-foreground/80 max-w-xl mx-auto text-xs sm:text-sm font-light font-inter leading-relaxed px-4 sm:px-0">
            By the people. For the people.
          </p>
        </motion.div>
        
        {/* Stats Panel */}
        <ErrorBoundary 
          title="Stats unavailable" 
          message="Unable to load statistics. Voting still works!"
        >
          <StatsPanel />
        </ErrorBoundary>
        
        {/* Controls - Mobile Optimized */}
        <div className="flex flex-col sm:flex-row gap-2 sm:gap-3 mb-4 sm:mb-6">
          <div className="flex-1 relative">
            <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 text-muted-foreground/60" size={16} />
            <input
              type="text"
              placeholder="Search LLMs..."
              value={searchTerm}
              onChange={(e) => setSearchTerm(e.target.value)}
              className="w-full pl-9 pr-4 py-2.5 sm:py-2 bg-card/50 border border-border/30 rounded-lg text-foreground text-sm font-light placeholder-muted-foreground/50 focus:outline-none focus:border-primary/50 focus:bg-card/70 transition-all font-inter touch-manipulation"
            />
          </div>
          
          <div className="flex gap-2">
            <select
              value={sortBy}
              onChange={(e) => setSortBy(e.target.value)}
              className="flex-1 sm:flex-initial px-3 sm:px-4 py-2.5 sm:py-2 bg-card/50 border border-border/30 rounded-lg text-foreground text-sm font-light focus:outline-none focus:border-primary/50 focus:bg-card/70 transition-all font-inter min-w-0 touch-manipulation"
            >
              <option value="votes">By Votes</option>
              <option value="name">By Name</option>
              <option value="company">By Company</option>
            </select>
          </div>
        </div>
        
        {/* Chart - Mobile Optimized */}
        <ErrorBoundary 
          title="Chart unavailable"
          message="Unable to display the voting chart."
        >
          <div className="mb-4 sm:mb-6 md:mb-8">
            <VoteChart sortBy={sortBy} />
          </div>
        </ErrorBoundary>
        
        {/* LLM Grid */}
        {loading ? (
          <div className="flex items-center justify-center h-64">
            <motion.div
              animate={{ rotate: 360 }}
              transition={{ duration: 1, repeat: Infinity, ease: "linear" }}
              className="w-8 h-8 border-4 border-primary border-t-transparent rounded-full"
            />
          </div>
        ) : (
          <motion.div
            layout
            className="grid gap-2 sm:gap-3 grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 xl:grid-cols-6 2xl:grid-cols-7"
          >
            <AnimatePresence mode="popLayout">
              {sortedLLMs.map((llm, index) => (
                <motion.div
                  key={llm.id}
                  layout
                  initial={{ opacity: 0, scale: 0.8 }}
                  animate={{ opacity: 1, scale: 1 }}
                  exit={{ opacity: 0, scale: 0.8 }}
                  transition={{ 
                    duration: 0.3,
                    delay: index * 0.02
                  }}
                >
                  <ErrorBoundary
                    title="Card error"
                    message={`Unable to display ${llm.name}`}
                    fallback={(error, reset) => (
                      <div className="bg-card/50 border border-red-500/20 rounded-lg p-4 text-center">
                        <p className="text-xs text-muted-foreground mb-2">Error loading {llm.name}</p>
                        <button 
                          onClick={reset}
                          className="text-xs text-primary hover:underline"
                        >
                          Retry
                        </button>
                      </div>
                    )}
                  >
                    <LLMCard llm={llm} index={index} />
                  </ErrorBoundary>
                </motion.div>
              ))}
            </AnimatePresence>
          </motion.div>
        )}
        
        {sortedLLMs.length === 0 && !loading && (
          <motion.div
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            className="text-center py-16"
          >
            <p className="text-muted-foreground text-lg">
              No LLMs found matching your search.
            </p>
          </motion.div>
        )}
      </main>
      
      {/* Footer - Mobile Optimized */}
      <footer className="border-t border-border/30 mt-8 sm:mt-12 py-4 sm:py-6">
        <div className="container mx-auto px-3 sm:px-4 text-center">
          <p className="text-muted-foreground/60 text-xs sm:text-sm font-light font-inter leading-relaxed">
            Made with ‚ù§Ô∏è by the Community
            <span className="hidden sm:inline"> | Real-time scheduled intervals powered by Supabase</span>
          </p>
          <p className="text-xs text-muted-foreground/40 mt-1 sm:mt-1.5 font-light font-inter">
            Vote responsibly. All votes update for everyone!
          </p>
        </div>
      </footer>
    </div>
  );
}

// File: c:\Users\Taimoor\Documents\GitHub\llm-popularity-tracker\app\sitemap.xml\route.js
export async function GET() {
  const baseUrl = 'https://llm-popularity-tracker.vercel.app'
  
  const sitemap = `<?xml version="1.0" encoding="UTF-8"?>
<urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9">
  <url>
    <loc>${baseUrl}</loc>
    <lastmod>${new Date().toISOString()}</lastmod>
    <changefreq>hourly</changefreq>
    <priority>1.0</priority>
  </url>
</urlset>`

  return new Response(sitemap, {
    headers: {
      'Content-Type': 'application/xml',
    },
  })
}

// File: c:\Users\Taimoor\Documents\GitHub\llm-popularity-tracker\components\ErrorBoundary.jsx
'use client';

import { Component } from 'react';
import { AlertCircle, RefreshCw } from 'lucide-react';

class ErrorBoundary extends Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false, error: null, errorInfo: null };
  }

  static getDerivedStateFromError(error) {
    return { hasError: true };
  }

  componentDidCatch(error, errorInfo) {
    console.error('Error caught by boundary:', error, errorInfo);
    this.setState({
      error: error,
      errorInfo: errorInfo
    });
  }

  handleReset = () => {
    this.setState({ hasError: false, error: null, errorInfo: null });
    // Optionally reload the page
    if (this.props.fallbackAction === 'reload') {
      window.location.reload();
    }
  };

  render() {
    if (this.state.hasError) {
      // Custom fallback UI
      if (this.props.fallback) {
        return this.props.fallback(this.state.error, this.handleReset);
      }

      // Default fallback UI
      return (
        <div className="min-h-[400px] flex items-center justify-center p-6">
          <div className="bg-card border border-red-500/20 rounded-lg p-6 max-w-md w-full">
            <div className="flex items-center gap-3 mb-4">
              <AlertCircle className="text-red-500" size={24} />
              <h2 className="text-lg font-semibold text-foreground">
                {this.props.title || 'Something went wrong'}
              </h2>
            </div>
            
            <p className="text-sm text-muted-foreground mb-4">
              {this.props.message || 'An unexpected error occurred. Please try refreshing the page.'}
            </p>
            
            {process.env.NODE_ENV === 'development' && this.state.error && (
              <details className="mb-4">
                <summary className="text-xs text-muted-foreground cursor-pointer hover:text-foreground">
                  Error details
                </summary>
                <pre className="mt-2 text-xs bg-black/20 p-2 rounded overflow-auto max-h-32">
                  {this.state.error.toString()}
                  {this.state.errorInfo?.componentStack}
                </pre>
              </details>
            )}
            
            <button
              onClick={this.handleReset}
              className="flex items-center gap-2 px-4 py-2 bg-primary hover:bg-primary-hover text-white rounded-lg transition-colors text-sm"
            >
              <RefreshCw size={16} />
              Try again
            </button>
          </div>
        </div>
      );
    }

    return this.props.children;
  }
}

export default ErrorBoundary;

// File: c:\Users\Taimoor\Documents\GitHub\llm-popularity-tracker\components\Header.jsx
'use client';

import { motion } from 'framer-motion';
import { Sparkles, Github } from 'lucide-react';

export default function Header() {
  return (
    <motion.header
      initial={{ opacity: 0, y: -20 }}
      animate={{ opacity: 1, y: 0 }}
      className="border-b border-border bg-card/50 backdrop-blur-sm sticky top-0 z-50"
    >
      <div className="container mx-auto px-3 sm:px-4 py-3 sm:py-4">
        <div className="flex items-center justify-between">
          <div className="flex items-center gap-2 sm:gap-3">
            <motion.div
              animate={{ rotate: 360 }}
              transition={{ duration: 20, repeat: Infinity, ease: "linear" }}
            >
              <Sparkles size={24} className="sm:w-8 sm:h-8 text-primary" />
            </motion.div>
            <div className="min-w-0 flex-1">
              <h1 className="text-base sm:text-xl font-light text-gradient font-sora tracking-tight truncate">LLM Popularity Tracker</h1>
              <p className="text-[10px] sm:text-xs text-muted-foreground/70 font-light font-inter truncate">Vote for your favorite AI models</p>
            </div>
          </div>
          
          <div className="flex items-center gap-2 sm:gap-4 flex-shrink-0">
            <motion.div
              whileHover={{ scale: 1.05 }}
              whileTap={{ scale: 0.95 }}
              className="text-[10px] sm:text-xs bg-primary/10 text-primary px-2 sm:px-3 py-1 sm:py-1.5 rounded-full font-light font-inter whitespace-nowrap"
            >
              <span className="hidden sm:inline">2025 Edition</span>
              <span className="sm:hidden">2025</span>
            </motion.div>
            {/* <motion.a
              href="https://github.com"
              target="_blank"
              rel="noopener noreferrer"
              whileHover={{ scale: 1.1 }}
              whileTap={{ scale: 0.9 }}
              className="text-muted-foreground hover:text-foreground transition-colors"
            >
              <Github size={20} />
            </motion.a> */}
          </div>
        </div>
      </div>
    </motion.header>
  );
}

// File: c:\Users\Taimoor\Documents\GitHub\llm-popularity-tracker\components\LLMCard.jsx
'use client';

import { useState } from 'react';
import { motion } from 'framer-motion';
import { ChevronUp, ChevronDown, X } from 'lucide-react';
import useVoteStore from '@/store/useVoteStore';
import { toast } from 'sonner';

export default function LLMCard({ llm, index }) {
  const [imageError, setImageError] = useState(false);
  const { vote, getUserVote, getVoteCount, isTrending, getRank } = useVoteStore();
  
  const userVote = getUserVote(llm.id);
  const voteCount = getVoteCount(llm.id);
  const trending = isTrending(llm.id);
  const rank = getRank(llm.id);
  
  const handleVote = async (voteType) => {
    console.log('üéØ [CARD] Vote button clicked:', { 
      llm: llm.name, 
      llmId: llm.id, 
      voteType, 
      currentUserVote: userVote,
      currentVoteCount: voteCount 
    });
    
    if (voteType === 0) {
      // Clear vote
      console.log('üéØ [CARD] Clearing vote for', llm.name);
      const result = await vote(llm.id, 0);
      if (result && result.success) {
        toast.success('Vote removed');
      }
    } else if (userVote !== voteType) {
      // Only vote if it's different from current vote
      console.log('üéØ [CARD] Casting new vote for', llm.name, ':', voteType === 1 ? 'UPVOTE' : 'DOWNVOTE');
      const result = await vote(llm.id, voteType);
      if (result && result.success) {
        toast.success(voteType === 1 ? 'Upvoted!' : 'Downvoted!');
      }
    } else {
      console.log('üéØ [CARD] Same vote clicked, ignoring:', { llm: llm.name, voteType });
    }
    // If clicking the same vote button, do nothing (no toggle)
  };
  
  return (
    <motion.div
      initial={{ opacity: 0, y: 20 }}
      animate={{ opacity: 1, y: 0 }}
      transition={{ delay: index * 0.02, duration: 0.3 }}
      whileHover={{ y: -2 }}
      className="relative bg-gradient-to-br from-card/90 to-card/60 border border-border/30 rounded-lg p-2.5 sm:p-3 shadow-sm hover:shadow-md transition-all duration-200 backdrop-blur-sm touch-manipulation"
    >
      {/* Rank Badge - Mobile Optimized */}
      {rank && rank <= 3 && (
        <div className={`absolute -top-1 -right-1 sm:-top-1.5 sm:-right-1.5 w-4 h-4 sm:w-5 sm:h-5 rounded-full flex items-center justify-center text-[9px] sm:text-[10px] font-medium shadow-sm
          ${rank === 1 ? 'bg-gradient-to-r from-yellow-400 to-amber-400 text-black' : ''}
          ${rank === 2 ? 'bg-gradient-to-r from-gray-300 to-gray-400 text-black' : ''}
          ${rank === 3 ? 'bg-gradient-to-r from-orange-400 to-orange-500 text-white' : ''}
        `}>
          {rank}
        </div>
      )}
      
      {/* Header with Logo and Info - Mobile Optimized */}
      <div className="flex items-start gap-2 sm:gap-2.5 mb-2.5 sm:mb-3">
        <div className="flex-shrink-0 w-7 h-7 sm:w-9 sm:h-9 rounded-md overflow-hidden bg-white/5 backdrop-blur-sm border border-white/10 flex items-center justify-center">
          <img 
            src={llm.logo} 
            alt={`${llm.company} logo`}
            className="w-5 h-5 sm:w-7 sm:h-7 object-contain"
            onError={() => setImageError(true)}
          />
        </div>
        <div className="flex-1 min-w-0">
          <h3 className="text-xs sm:text-sm font-medium text-foreground truncate font-sora leading-tight">{llm.name}</h3>
          <p className="text-[10px] sm:text-xs text-muted-foreground/70 font-light font-inter mt-0.5">{llm.company}</p>
          <p className="text-[9px] sm:text-[10px] text-muted-foreground/50 font-light font-inter">{llm.releaseYear}</p>
        </div>
      </div>
      
      {/* Vote Section - Mobile Optimized */}
      <div className="flex items-center justify-between bg-black/10 backdrop-blur-sm rounded-md p-1.5 sm:p-2">
        <motion.button
          whileTap={userVote !== 1 ? { scale: 0.9 } : {}}
          whileHover={userVote !== 1 ? { scale: 1.1 } : {}}
          onClick={() => handleVote(1)}
          disabled={userVote === 1}
          className={`flex items-center justify-center w-6 h-6 sm:w-7 sm:h-7 rounded-md transition-all touch-manipulation ${
            userVote === 1
              ? 'bg-gradient-to-r from-green-500 to-emerald-500 text-white shadow-sm shadow-green-500/20 cursor-default'
              : 'bg-white/5 hover:bg-green-500/15 text-green-400 hover:text-green-300 border border-green-400/20 cursor-pointer active:bg-green-500/20'
          }`}
          aria-label="Upvote"
          title={userVote === 1 ? "You upvoted this" : "Upvote"}
        >
          <ChevronUp size={14} className="sm:w-4 sm:h-4" strokeWidth={2} />
        </motion.button>
        
        <div className="flex items-center gap-1 sm:gap-1.5">
          {/* Vote count - Mobile Optimized */}
          <div className="flex flex-col items-center px-1 sm:px-2">
            <span className={`text-xs sm:text-sm font-medium font-mono ${
              voteCount > 0 ? 'text-green-400' : voteCount < 0 ? 'text-red-400' : 'text-gray-500'
            }`}>
              {voteCount > 0 ? '+' : ''}{voteCount}
            </span>
            <span className="text-[8px] sm:text-[9px] text-muted-foreground/50 font-inter font-light">votes</span>
          </div>
          
          {/* Clear vote button - Mobile Optimized */}
          {userVote !== 0 && (
            <motion.button
              initial={{ scale: 0, opacity: 0 }}
              animate={{ scale: 1, opacity: 1 }}
              whileTap={{ scale: 0.8 }}
              whileHover={{ scale: 1.1 }}
              onClick={() => handleVote(0)}
              className="flex items-center justify-center w-4 h-4 sm:w-5 sm:h-5 rounded-full bg-white/5 hover:bg-white/10 active:bg-white/15 text-gray-500 hover:text-gray-300 border border-gray-500/20 transition-all touch-manipulation"
              aria-label="Clear vote"
              title="Clear vote"
            >
              <X size={8} className="sm:w-2.5 sm:h-2.5" strokeWidth={2} />
            </motion.button>
          )}
        </div>
        
        <motion.button
          whileTap={userVote !== -1 ? { scale: 0.9 } : {}}
          whileHover={userVote !== -1 ? { scale: 1.1 } : {}}
          onClick={() => handleVote(-1)}
          disabled={userVote === -1}
          className={`flex items-center justify-center w-6 h-6 sm:w-7 sm:h-7 rounded-md transition-all touch-manipulation ${
            userVote === -1
              ? 'bg-gradient-to-r from-red-500 to-rose-500 text-white shadow-sm shadow-red-500/20 cursor-default'
              : 'bg-white/5 hover:bg-red-500/15 text-red-400 hover:text-red-300 border border-red-400/20 cursor-pointer active:bg-red-500/20'
          }`}
          aria-label="Downvote"
          title={userVote === -1 ? "You downvoted this" : "Downvote"}
        >
          <ChevronDown size={14} className="sm:w-4 sm:h-4" strokeWidth={2} />
        </motion.button>
      </div>
    </motion.div>
  );
}

// File: c:\Users\Taimoor\Documents\GitHub\llm-popularity-tracker\components\StatsPanel.jsx
'use client';

import { motion } from 'framer-motion';
import { TrendingUp, Users, Clock, Trophy, Activity } from 'lucide-react';
import useVoteStore from '@/store/useVoteStore';

export default function StatsPanel() {
  const { stats } = useVoteStore();
  
  const statCards = [
    {
      icon: Users,
      label: 'Total Votes',
      value: stats.totalVotes || 0,
      color: 'text-primary',
      bgColor: 'bg-primary/10',
    },
    {
      icon: Activity,
      label: 'Votes Today',
      value: stats.votesToday || 0,
      color: 'text-success',
      bgColor: 'bg-success/10',
    },
    {
      icon: Clock,
      label: 'Last Hour',
      value: stats.votesLastHour || 0,
      color: 'text-accent',
      bgColor: 'bg-accent/10',
    },
    {
      icon: Trophy,
      label: 'Leading',
      value: stats.topModel || 'None',
      color: 'text-yellow-500',
      bgColor: 'bg-yellow-500/10',
      small: true,
    },
  ];
  
  return (
    <div className="grid grid-cols-2 sm:grid-cols-2 lg:grid-cols-4 gap-2 sm:gap-3 md:gap-4 mb-4 sm:mb-6 md:mb-8">
      {statCards.map((stat, index) => (
        <motion.div
          key={stat.label}
          initial={{ opacity: 0, scale: 0.9 }}
          animate={{ opacity: 1, scale: 1 }}
          transition={{ delay: index * 0.1 }}
          className="flex justify-between bg-card border border-border rounded-lg p-3 sm:p-4"
        >
          <div>
            <div className="flex items-center justify-between mb-1.5 sm:mb-2">
              <div className={`p-1.5 sm:p-2 rounded-lg ${stat.bgColor}`}>
                <stat.icon size={16} className={`sm:w-5 sm:h-5 ${stat.color}`} />
              </div>
              {stat.label === 'Last Hour' && stats.votesLastHour > 0 && (
                <TrendingUp size={14} className="sm:w-4 sm:h-4 text-success" />
              )}
            </div>
            <p className="text-[10px] sm:text-xs text-muted-foreground/70 font-light font-inter leading-tight">{stat.label}</p>
          </div>
          <p className="text-xl sm:text-2xl md:text-3xl font-extralight text-foreground font-sora leading-none">
            {typeof stat.value === 'number' ? stat.value.toLocaleString() : stat.value}
          </p>
        </motion.div>
      ))}
    </div>
  );
}

// File: c:\Users\Taimoor\Documents\GitHub\llm-popularity-tracker\components\VoteChart.jsx
'use client';

import { useEffect, useState } from 'react';
import { motion } from 'framer-motion';
import {
  BarChart,
  Bar,
  XAxis,
  YAxis,
  CartesianGrid,
  Tooltip,
  ResponsiveContainer,
  Cell,
} from 'recharts';
import useVoteStore from '@/store/useVoteStore';
import { BarChart3, ChevronLeft, ChevronRight } from 'lucide-react';

export default function VoteChart({ sortBy = 'votes' }) {
  const [isMobile, setIsMobile] = useState(false);
  const [currentPage, setCurrentPage] = useState(0);
  const { votes, llms, getVoteCount } = useVoteStore();
  
  // Check if mobile
  useEffect(() => {
    const checkMobile = () => {
      setIsMobile(window.innerWidth < 768);
    };
    
    checkMobile();
    window.addEventListener('resize', checkMobile);
    return () => window.removeEventListener('resize', checkMobile);
  }, []);
  
  // Prepare chart data - show ALL LLMs with their vote counts
  const allChartData = llms.map((llm) => {
    const voteCount = votes[llm.id] || 0;
    return {
      name: llm.name,
      votes: voteCount,
      color: llm.color || 'from-gray-500 to-gray-600',
      id: llm.id,
      company: llm.company,
    };
  }).sort((a, b) => {
    // Use the same sorting logic as the main page
    if (sortBy === 'votes') {
      return b.votes - a.votes; // Sort by votes descending
    } else if (sortBy === 'name') {
      return a.name.localeCompare(b.name); // Sort by name ascending
    } else if (sortBy === 'company') {
      return a.company.localeCompare(b.company); // Sort by company ascending
    }
    return 0;
  });
  
  // Mobile pagination
  const itemsPerPage = isMobile ? 6 : allChartData.length;
  const totalPages = Math.ceil(allChartData.length / itemsPerPage);
  const startIndex = currentPage * itemsPerPage;
  const chartData = isMobile 
    ? allChartData.slice(startIndex, startIndex + itemsPerPage)
    : allChartData;
  
  // Extract gradient colors for bars
  const getBarColor = (color) => {
    const colors = color.match(/from-(\w+)-\d+\sto-(\w+)-\d+/);
    if (colors) {
      const colorMap = {
        green: '#10b981',
        emerald: '#10b981',
        orange: '#f59e0b',
        amber: '#f59e0b',
        blue: '#3b82f6',
        cyan: '#06b6d4',
        purple: '#8b5cf6',
        violet: '#8b5cf6',
        red: '#ef4444',
        pink: '#ec4899',
        indigo: '#6366f1',
        gray: '#6b7280',
        slate: '#64748b',
        teal: '#14b8a6',
        yellow: '#eab308',
      };
      return colorMap[colors[1]] || '#6b7280';
    }
    return '#6b7280';
  };
  
  const CustomTooltip = ({ active, payload }) => {
    if (active && payload && payload[0]) {
      return (
        <motion.div 
          initial={{ opacity: 0, scale: 0.9 }}
          animate={{ opacity: 1, scale: 1 }}
          className="bg-card/95 backdrop-blur-sm border border-border rounded-lg shadow-xl p-3 pointer-events-none"
        >
          <p className="font-semibold text-foreground text-sm">{payload[0].payload.name}</p>
          <p className="text-sm text-muted-foreground">
            Votes: <span className="text-primary font-bold">{payload[0].value}</span>
          </p>
        </motion.div>
      );
    }
    return null;
  };

  // Custom label formatter for mobile
  const formatLabel = (name) => {
    if (!isMobile) return name;
    
    // Truncate long names on mobile
    if (name.length > 8) {
      return name.substring(0, 6) + '...';
    }
    return name;
  };
  
  const nextPage = () => {
    setCurrentPage((prev) => (prev + 1) % totalPages);
  };
  
  const prevPage = () => {
    setCurrentPage((prev) => (prev - 1 + totalPages) % totalPages);
  };
  
  return (
    <motion.div
      initial={{ opacity: 0, y: 20 }}
      animate={{ opacity: 1, y: 0 }}
      className="bg-card border border-border rounded-lg p-4 md:p-6"
    >
      <div className="flex items-center justify-between mb-4 md:mb-6">
        <h2 className="text-lg md:text-xl font-bold text-foreground flex items-center gap-2">
          <BarChart3 size={isMobile ? 20 : 24} className="text-primary" />
          <span className="font-sora">All LLM {sortBy === 'votes' ? 'Votes' : sortBy === 'name' ? 'Names' : 'Companies'}</span>
        </h2>
        
        {/* Pagination controls */}
        {totalPages > 1 && (
          <div className="flex items-center gap-2">
            <button
              onClick={prevPage}
              className={`p-2 rounded-lg bg-muted/10 text-muted-foreground transition-colors disabled:opacity-50 ${
                isMobile ? 'active:bg-muted/20' : 'md:hover:bg-muted/20'
              }`}
              disabled={currentPage === 0}
            >
              <ChevronLeft size={16} />
            </button>
            <span className="text-xs text-muted-foreground font-mono">
              {currentPage + 1}/{totalPages}
            </span>
            <button
              onClick={nextPage}
              className={`p-2 rounded-lg bg-muted/10 text-muted-foreground transition-colors disabled:opacity-50 ${
                isMobile ? 'active:bg-muted/20' : 'md:hover:bg-muted/20'
              }`}
              disabled={currentPage === totalPages - 1}
            >
              <ChevronRight size={16} />
            </button>
          </div>
        )}
      </div>
      
      <ResponsiveContainer 
        width="100%" 
        height={isMobile ? 280 : 400}
        style={{ 
          backgroundColor: 'transparent',
          cursor: 'pointer'
        }}
      >
        <BarChart 
          data={chartData} 
          margin={{ 
            top: 20, 
            right: isMobile ? 0 : 30, 
            left: isMobile ? 0 : -16, 
            bottom: isMobile ? 0 : 80 
          }}
          style={{ backgroundColor: 'transparent' }}
        >
          <CartesianGrid strokeDasharray="3 3" stroke="#27272a" opacity={0.3} />
          <XAxis
            dataKey="name"
            angle={isMobile ? -45 : -45}
            textAnchor="end"
            height={isMobile ? 60 : 80}
            tick={{ 
              fill: '#9ca3af', 
              fontSize: isMobile ? 10 : 11,
              fontFamily: 'var(--font-inter)'
            }}
            stroke="#27272a"
            interval={0}
            tickFormatter={formatLabel}
          />
          <YAxis
            tick={{ 
              fill: '#9ca3af', 
              fontSize: isMobile ? 10 : 12,
              fontFamily: 'var(--font-inter)'
            }}
            stroke="#27272a"
            domain={['dataMin - 1', 'dataMax + 1']}
            width={isMobile ? 35 : 50}
          />
          <Tooltip 
            content={<CustomTooltip />} 
            cursor={{ fill: 'transparent' }}
            wrapperStyle={{ 
              backgroundColor: 'transparent',
              border: 'none',
              outline: 'none'
            }}
          />
          <Bar 
            dataKey="votes" 
            radius={[4, 4, 0, 0]}
            maxBarSize={isMobile ? 40 : 60}
          >
            {chartData.map((entry, index) => (
              <Cell key={`cell-${index}`} fill={getBarColor(entry.color)} />
            ))}
          </Bar>
        </BarChart>
      </ResponsiveContainer>
      
      {/* Pagination dots */}
      {totalPages > 1 && (
        <div className="flex justify-center mt-4 gap-2">
          {Array.from({ length: totalPages }).map((_, index) => (
            <button
              key={index}
              onClick={() => setCurrentPage(index)}
              className={`w-2 h-2 rounded-full transition-colors ${
                index === currentPage 
                  ? 'bg-primary' 
                  : `bg-muted-foreground/30 ${isMobile ? 'active:bg-muted-foreground/60' : 'md:hover:bg-muted-foreground/50'}`
              }`}
            />
          ))}
        </div>
      )}
      
      {/* Helper text for pagination */}
      {totalPages > 1 && (
        <p className="text-xs text-muted-foreground/70 text-center mt-3 font-light">
          {isMobile 
            ? `Tap arrows or dots to see more ‚Ä¢ Showing ${Math.min(itemsPerPage, chartData.length)} of ${allChartData.length} LLMs`
            : `Use arrows or click dots to navigate ‚Ä¢ Showing ${Math.min(itemsPerPage, chartData.length)} of ${allChartData.length} LLMs`
          }
        </p>
      )}
    </motion.div>
  );
}

// File: c:\Users\Taimoor\Documents\GitHub\llm-popularity-tracker\lib\fingerprint.js
import FingerprintJS from '@fingerprintjs/fingerprintjs';

class FingerprintService {
  constructor() {
    this.fpPromise = null;
    this.cachedFingerprint = null;
    this.storageKey = 'llm-tracker-fingerprint';
  }

  async initialize() {
    if (!this.fpPromise) {
      this.fpPromise = FingerprintJS.load();
    }
    return this.fpPromise;
  }

  async getFingerprint() {
    // Return cached fingerprint if available
    if (this.cachedFingerprint) {
      return this.cachedFingerprint;
    }

    // Try to get from localStorage first
    const storedFingerprint = this.getStoredFingerprint();
    if (storedFingerprint) {
      this.cachedFingerprint = storedFingerprint;
      return storedFingerprint;
    }

    // Generate new fingerprint
    try {
      const fp = await this.initialize();
      const result = await fp.get();
      const fingerprint = result.visitorId;
      
      // Store for future use
      this.storeFingerprint(fingerprint);
      this.cachedFingerprint = fingerprint;
      
      return fingerprint;
    } catch (error) {
      console.error('Failed to generate fingerprint:', error);
      // Fallback to a random ID stored in localStorage
      return this.generateFallbackFingerprint();
    }
  }

  getStoredFingerprint() {
    if (typeof window === 'undefined') return null;
    
    try {
      return localStorage.getItem(this.storageKey);
    } catch (error) {
      console.error('Failed to read stored fingerprint:', error);
      return null;
    }
  }

  storeFingerprint(fingerprint) {
    if (typeof window === 'undefined') return;
    
    try {
      localStorage.setItem(this.storageKey, fingerprint);
      // Also store in sessionStorage as backup
      sessionStorage.setItem(this.storageKey, fingerprint);
    } catch (error) {
      console.error('Failed to store fingerprint:', error);
    }
  }

  generateFallbackFingerprint() {
    // Generate a random fallback ID
    const fallbackId = 'fallback_' + Math.random().toString(36).substring(2) + Date.now().toString(36);
    this.storeFingerprint(fallbackId);
    this.cachedFingerprint = fallbackId;
    return fallbackId;
  }

  // Get fingerprint with multiple fallback options
  async getFingerprintWithFallbacks() {
    // Primary: Generated fingerprint
    try {
      return await this.getFingerprint();
    } catch (error) {
      console.error('Primary fingerprint failed:', error);
    }

    // Secondary: SessionStorage
    try {
      const sessionFingerprint = sessionStorage.getItem(this.storageKey);
      if (sessionFingerprint) {
        this.cachedFingerprint = sessionFingerprint;
        return sessionFingerprint;
      }
    } catch (error) {
      console.error('SessionStorage fallback failed:', error);
    }

    // Tertiary: Generate new fallback
    return this.generateFallbackFingerprint();
  }

  // Clear stored fingerprint (for testing or user request)
  clearFingerprint() {
    this.cachedFingerprint = null;
    if (typeof window !== 'undefined') {
      try {
        localStorage.removeItem(this.storageKey);
        sessionStorage.removeItem(this.storageKey);
      } catch (error) {
        console.error('Failed to clear fingerprint:', error);
      }
    }
  }
}

// Singleton instance
const fingerprintService = new FingerprintService();

export default fingerprintService;

// File: c:\Users\Taimoor\Documents\GitHub\llm-popularity-tracker\lib\llm-data.js
export const llmData = [
  {
    id: "gpt-5",
    name: "GPT-5",
    company: "OpenAI",
    releaseYear: 2025,
    logo: "/logos/openai.png",
    color: "from-green-500 to-emerald-600"
  },
  {
    id: "claude-4-sonnet",
    name: "Claude 4 Sonnet",
    company: "Anthropic",
    releaseYear: 2025,
    logo: "/logos/anthropic.png",
    color: "from-orange-500 to-amber-600"
  },
  {
    id: "claude-4-opus",
    name: "Claude 4 Opus",
    company: "Anthropic", 
    releaseYear: 2025,
    logo: "/logos/anthropic.png",
    color: "from-orange-600 to-red-600"
  },
  {
    id: "gemini-2-5-pro",
    name: "Gemini 2.5 Pro",
    company: "Google",
    releaseYear: 2025,
    logo: "/logos/google.png",
    color: "from-blue-500 to-cyan-600"
  },
  {
    id: "deepseek-r1",
    name: "DeepSeek R1",
    company: "DeepSeek",
    releaseYear: 2025,
    logo: "/logos/deepseek.png",
    color: "from-slate-500 to-gray-600"
  },
  {
    id: "gpt-4o",
    name: "GPT-4o",
    company: "OpenAI",
    releaseYear: 2024,
    logo: "/logos/openai.png",
    color: "from-green-400 to-emerald-500"
  },
  {
    id: "o3",
    name: "OpenAI o3",
    company: "OpenAI",
    releaseYear: 2025,
    logo: "/logos/openai.png",
    color: "from-green-600 to-teal-600"
  },
  {
    id: "o4-mini",
    name: "OpenAI o4-mini",
    company: "OpenAI",
    releaseYear: 2025,
    logo: "/logos/openai.png",
    color: "from-green-500 to-blue-600"
  },
  {
    id: "llama-4-maverick",
    name: "Llama 4 Maverick",
    company: "Meta",
    releaseYear: 2025,
    logo: "/logos/meta.png",
    color: "from-purple-500 to-violet-600"
  },
  {
    id: "llama-4-scout",
    name: "Llama 4 Scout",
    company: "Meta",
    releaseYear: 2025,
    logo: "/logos/meta.png",
    color: "from-purple-600 to-indigo-600"
  },
  {
    id: "grok-3",
    name: "Grok 3",
    company: "xAI",
    releaseYear: 2025,
    logo: "/logos/xai.png",
    color: "from-yellow-500 to-orange-600"
  },
  {
    id: "gemini-2-5-flash",
    name: "Gemini 2.5 Flash",
    company: "Google",
    releaseYear: 2025,
    logo: "/logos/google.png",
    color: "from-blue-400 to-cyan-500"
  },
  {
    id: "qwen-2-5",
    name: "Qwen 2.5",
    company: "Alibaba",
    releaseYear: 2024,
    logo: "/logos/alibaba.png",
    color: "from-rose-500 to-red-600"
  },
  {
    id: "mistral-large-2",
    name: "Mistral Large 2",
    company: "Mistral AI",
    releaseYear: 2024,
    logo: "/logos/mistral.png",
    color: "from-red-500 to-pink-600"
  },
  {
    id: "command-r-plus",
    name: "Command R+",
    company: "Cohere",
    releaseYear: 2024,
    logo: "/logos/cohere.png",
    color: "from-indigo-500 to-blue-600"
  },
  {
    id: "gpt-4-1",
    name: "GPT-4.1",
    company: "OpenAI",
    releaseYear: 2025,
    logo: "/logos/openai.png",
    color: "from-green-500 to-emerald-500"
  },
  {
    id: "deepseek-v3",
    name: "DeepSeek V3",
    company: "DeepSeek",
    releaseYear: 2024,
    logo: "/logos/deepseek.png",
    color: "from-slate-600 to-zinc-600"
  },
  {
    id: "yi-lightning",
    name: "Yi Lightning",
    company: "01.AI",
    releaseYear: 2024,
    logo: "/logos/01ai.png",
    color: "from-lime-500 to-green-600"
  },
  {
    id: "phi-4",
    name: "Phi-4",
    company: "Microsoft",
    releaseYear: 2025,
    logo: "/logos/microsoft.png",
    color: "from-sky-500 to-blue-600"
  },
  {
    id: "ernie-4-turbo",
    name: "ERNIE 4.0 Turbo",
    company: "Baidu",
    releaseYear: 2024,
    logo: "/logos/baidu.png",
    color: "from-pink-500 to-rose-600"
  }
];

// File: c:\Users\Taimoor\Documents\GitHub\llm-popularity-tracker\lib\supabase\client.js
import { createClient } from '@supabase/supabase-js'

const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL
const supabaseAnonKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY

if (!supabaseUrl || !supabaseAnonKey) {
  console.warn('Supabase credentials not found. Please set NEXT_PUBLIC_SUPABASE_URL and NEXT_PUBLIC_SUPABASE_ANON_KEY')
}

export const supabase = createClient(
  supabaseUrl || '',
  supabaseAnonKey || '',
  {
    auth: {
      persistSession: false
    },
    realtime: {
      params: {
        eventsPerSecond: 10
      }
    },
    global: {
      headers: {
        'x-application-name': 'llm-popularity-tracker'
      }
    }
  }
)

// File: c:\Users\Taimoor\Documents\GitHub\llm-popularity-tracker\lib\supabase\vote-manager.js
// lib/supabase/vote-manager.js
import { supabase } from './client'

class SupabaseVoteManager {
  constructor() {
    this.channel = null
    this.subscriptions = new Map()
    this.retryCount = 0
    this.maxRetries = 5
    this.retryDelay = 1000
    this.isConnecting = false
    this.connectionCallbacks = null
    this.statsInterval = null
  }

  // YOUR ORIGINAL initializeRealtime
  async initializeRealtime(onVoteUpdate, onStatsUpdate) {
    this.connectionCallbacks = { onVoteUpdate, onStatsUpdate }
    
    if (this.isConnecting) {
      console.log('üîÑ Connection already in progress...')
      return false
    }
    
    this.isConnecting = true
    
    try {
      if (this.channel) {
        await this.cleanup()
      }
      
      this.channel = supabase
        .channel('optimized-votes')
        .on('postgres_changes', {
          event: '*',
          schema: 'public',
          table: 'vote_stats_aggregate'
        }, (payload) => {
          console.log('üìä Aggregate update received:', payload.new?.llm_id)
          if (onVoteUpdate && payload.new) {
            onVoteUpdate({
              llmId: payload.new.llm_id,
              votes: payload.new.total_votes,
              upvotes: payload.new.upvotes,
              downvotes: payload.new.downvotes,
              uniqueVoters: payload.new.unique_voters
            })
          }
        })
        .subscribe((status) => {
          console.log('‚úÖ Realtime subscription status:', status)
          
          if (status === 'SUBSCRIBED') {
            this.retryCount = 0
            this.retryDelay = 1000
            this.isConnecting = false
            this.startStatsPolling(onStatsUpdate)
          } else if (status === 'CLOSED' || status === 'CHANNEL_ERROR') {
            this.handleConnectionError()
          }
        })

      setTimeout(() => {
        if (this.isConnecting) {
          console.warn('‚ö†Ô∏è Connection timeout, attempting retry...')
          this.handleConnectionError()
        }
      }, 10000)

      this.isConnecting = false
      return true
    } catch (error) {
      console.error('‚ùå Failed to initialize realtime:', error)
      this.isConnecting = false
      this.handleConnectionError()
      return false
    }
  }
  
  startStatsPolling(onStatsUpdate) {
    if (this.statsInterval) {
      clearInterval(this.statsInterval)
    }
    
    this.fetchAndUpdateStats(onStatsUpdate)
    
    this.statsInterval = setInterval(() => {
      this.fetchAndUpdateStats(onStatsUpdate)
    }, 30000)
  }
  
  async fetchAndUpdateStats(onStatsUpdate) {
    try {
      const stats = await this.getStats()
      if (onStatsUpdate) {
        console.log('üìä Polling global stats update')
        onStatsUpdate({
          totalVotes: stats.totalVotes || 0,
          uniqueVoters: stats.uniqueVoters || 0,
          votesLastHour: stats.votesLastHour || 0,
          votesToday: stats.votesToday || 0,
          topModel: stats.topModel,
          topModelVotes: stats.topModelVotes || 0
        })
      }
    } catch (error) {
      console.error('Failed to fetch stats:', error)
    }
  }
  
  async handleConnectionError() {
    this.isConnecting = false
    
    if (this.retryCount >= this.maxRetries) {
      console.error('üõë Max retries reached, giving up on realtime connection')
      return
    }
    
    this.retryCount++
    const delay = Math.min(this.retryDelay * Math.pow(2, this.retryCount - 1), 30000)
    
    console.log(`üîÑ Retrying connection in ${delay/1000}s (attempt ${this.retryCount}/${this.maxRetries})`)
    
    setTimeout(() => {
      if (this.connectionCallbacks) {
        this.initializeRealtime(
          this.connectionCallbacks.onVoteUpdate,
          this.connectionCallbacks.onStatsUpdate
        )
      }
    }, delay)
  }

  // YOUR ORIGINAL vote function (no p_use_queue parameter!)
  async vote(llmId, fingerprint, voteType, metadata = {}) {
    try {
      const { data, error } = await supabase
        .rpc('handle_vote', {
          p_llm_id: llmId,
          p_fingerprint: fingerprint,
          p_vote_type: voteType,
          p_ip_address: metadata.ip || null,
          p_user_agent: metadata.userAgent || null
        })

      if (error) {
        throw error
      }

      // Handle database rate limiting response
      if (!data.success && data.wait_seconds) {
        return {
          success: false,
          error: `Rate limited. Please wait ${Math.ceil(data.wait_seconds)} seconds before voting again.`,
          wait_seconds: data.wait_seconds
        }
      }

      return {
        success: data.success,
        previousVote: data.previous_vote,
        newVote: data.new_vote,
        voteCount: data.vote_count,
        message: data.message,
        wait_seconds: data.wait_seconds
      }
    } catch (error) {
      console.error('Vote failed:', error)
      return {
        success: false,
        error: error.message
      }
    }
  }

  // YOUR ORIGINAL getVoteCounts
  async getVoteCounts() {
    try {
      const { data, error } = await supabase
        .from('vote_stats_aggregate')
        .select('llm_id, total_votes')
        .order('total_votes', { ascending: false })

      if (error) throw error

      const votes = {}
      data.forEach(item => {
        votes[item.llm_id] = item.total_votes || 0
      })

      return votes
    } catch (error) {
      console.error('Failed to get vote counts:', error)
      return {}
    }
  }

  async getUserVotes(fingerprint) {
    try {
      const { data, error } = await supabase
        .rpc('get_user_votes', {
          p_fingerprint: fingerprint
        })

      if (error) throw error
      return data || {}
    } catch (error) {
      console.error('Failed to get user votes:', error)
      return {}
    }
  }

  async getLLMsWithVotes() {
    try {
      const { data, error } = await supabase
        .from('vote_stats_aggregate')
        .select(`
          llm_id,
          total_votes,
          upvotes,
          downvotes,
          unique_voters,
          llms!inner(
            name,
            company,
            description,
            logo,
            image,
            color,
            release_year,
            use_cases
          )
        `)
        .order('total_votes', { ascending: false })

      if (error) throw error
      return data || []
    } catch (error) {
      console.error('Failed to get LLMs with votes:', error)
      return []
    }
  }

  async getRankings() {
    try {
      const { data, error } = await supabase
        .from('vote_stats_aggregate')
        .select('llm_id, total_votes')
        .order('total_votes', { ascending: false })
        .limit(10)

      if (error) throw error

      return (data || []).map((item, index) => ({
        id: item.llm_id,
        name: item.llm_id,
        count: item.total_votes || 0,
        rank: index + 1
      }))
    } catch (error) {
      console.error('Failed to get rankings:', error)
      return []
    }
  }

  async getStats() {
    try {
      const { data, error } = await supabase
        .from('global_stats')
        .select('*')
        .single()

      if (error) throw error

      let topModelName = null
      if (data?.top_model) {
        const { data: llmData } = await supabase
          .from('llms')
          .select('name')
          .eq('id', data.top_model)
          .single()
        
        topModelName = llmData?.name || data.top_model
      }

      return {
        totalVotes: data?.total_votes || 0,
        uniqueVoters: data?.unique_voters || 0,
        votesLastHour: data?.votes_last_hour || 0,
        votesToday: data?.votes_today || 0,
        topModel: topModelName,
        topModelVotes: data?.top_model_votes || 0,
        lastUpdated: data?.last_updated || new Date().toISOString()
      }
    } catch (error) {
      console.error('Failed to get stats:', error)
      return {
        totalVotes: 0,
        uniqueVoters: 0,
        votesLastHour: 0,
        votesToday: 0,
        topModel: null,
        topModelVotes: 0,
        lastUpdated: new Date().toISOString()
      }
    }
  }

  async syncUserData(fingerprint) {
    try {
      const userVotes = await this.getUserVotes(fingerprint)
      const voteCounts = await this.getVoteCounts()
      const rankings = await this.getRankings()
      const stats = await this.getStats()

      return {
        success: true,
        userVotes,
        votes: voteCounts,
        rankings,
        stats
      }
    } catch (error) {
      console.error('Failed to sync user data:', error)
      return {
        success: false,
        error: error.message
      }
    }
  }

  cleanup() {
    if (this.channel) {
      supabase.removeChannel(this.channel)
      this.channel = null
    }
    if (this.statsInterval) {
      clearInterval(this.statsInterval)
      this.statsInterval = null
    }
    this.subscriptions.clear()
    this.retryCount = 0
    this.isConnecting = false
    this.connectionCallbacks = null
  }
  
  async reconnect() {
    console.log('üîÑ Manual reconnect requested')
    this.retryCount = 0
    this.retryDelay = 1000
    
    if (this.connectionCallbacks) {
      return this.initializeRealtime(
        this.connectionCallbacks.onVoteUpdate,
        this.connectionCallbacks.onStatsUpdate
      )
    }
    return false
  }
}

export const voteManager = new SupabaseVoteManager()
export default voteManager

// File: c:\Users\Taimoor\Documents\GitHub\llm-popularity-tracker\store\useVoteStore.js
import { create } from 'zustand';
import { llmData } from '@/lib/llm-data';
import fingerprintService from '@/lib/fingerprint';
import voteManager from '@/lib/supabase/vote-manager';

const useVoteStore = create((set, get) => ({
  llms: llmData,
  votes: {},
  userVotes: {},
  rankings: [],
  stats: {
    totalVotes: 0,
    uniqueVoters: 0,
    votesLastHour: 0,
    votesToday: 0,
    topModel: null,
    topModelVotes: 0,
  },
  loading: false,
  error: null,
  lastUpdate: null,
  fingerprint: null,
  realtimeConnected: false,
  lastVoteTime: 0,
  voteThrottleMs: 2000, // 2 second throttle between votes
  
  // Initialize votes and real-time connection
  initializeVotes: async () => {
    console.log('üöÄ Initializing Supabase vote store...');
    set({ loading: true, error: null });
    
    try {
      // Get fingerprint
      const fingerprint = await fingerprintService.getFingerprintWithFallbacks();
      console.log('üîç Fingerprint obtained:', fingerprint.substring(0, 8) + '...');
      set({ fingerprint });
      
      // Sync initial data
      const syncResult = await voteManager.syncUserData(fingerprint);
      
      if (syncResult.success) {
        set({
          votes: syncResult.votes || {},
          userVotes: syncResult.userVotes || {},
          rankings: syncResult.rankings || [],
          stats: syncResult.stats || get().stats,
          loading: false,
          lastUpdate: new Date(),
        });
        
        // Initialize real-time subscriptions with optimized partial updates
        const realtimeSuccess = await voteManager.initializeRealtime(
          // Partial vote update - only update the specific LLM that changed
          (voteUpdate) => {
            console.log('üì° Real-time aggregate update for:', voteUpdate.llmId);
            const currentVotes = get().votes;
            set({ 
              votes: {
                ...currentVotes,
                [voteUpdate.llmId]: voteUpdate.votes
              },
              lastUpdate: new Date()
            });
            get().updateRankings();
          },
          // Global stats update
          (statsUpdate) => {
            console.log('üìä Real-time global stats update');
            set({ 
              stats: {
                totalVotes: statsUpdate.totalVotes || 0,
                uniqueVoters: statsUpdate.uniqueVoters || 0,
                votesLastHour: statsUpdate.votesLastHour || 0,
                votesToday: statsUpdate.votesToday || 0,
                topModel: statsUpdate.topModel,
                topModelVotes: statsUpdate.topModelVotes || 0
              }
            });
          }
        );
        
        set({ realtimeConnected: realtimeSuccess });
        console.log('‚úÖ Vote store initialized with real-time:', realtimeSuccess);
      } else {
        throw new Error(syncResult.error || 'Failed to sync data');
      }
    } catch (error) {
      console.error('‚ùå Failed to initialize:', error);
      set({ 
        loading: false, 
        error: 'Failed to connect to voting system',
      });
      
      // Initialize with zero votes as fallback
      const initialVotes = {};
      llmData.forEach(llm => {
        initialVotes[llm.id] = 0;
      });
      set({ votes: initialVotes });
    }
  },
  
  // Vote for an LLM
  vote: async (llmId, voteType) => {
    console.log('üó≥Ô∏è Voting:', { llmId, voteType });
    
    const fingerprint = get().fingerprint;
    if (!fingerprint) {
      console.error('No fingerprint available');
      return;
    }
    
    // Check rate limiting
    const now = Date.now();
    const timeSinceLastVote = now - get().lastVoteTime;
    const throttleMs = get().voteThrottleMs;
    
    if (timeSinceLastVote < throttleMs) {
      const waitTime = Math.ceil((throttleMs - timeSinceLastVote) / 1000);
      set({ error: `Please wait ${waitTime} second${waitTime > 1 ? 's' : ''} between votes` });
      setTimeout(() => set({ error: null }), 2000);
      console.log(`Rate limited: ${timeSinceLastVote}ms since last vote, need ${throttleMs}ms`);
      return { success: false, rateLimited: true };
    }
    
    const currentUserVote = get().userVotes[llmId] || 0;
    
    // Don't vote if it's the same
    if (currentUserVote === voteType) {
      console.log('Same vote, ignoring');
      return { success: false, sameVote: true };
    }
    
    // Update last vote time
    set({ lastVoteTime: now });
    
    // Optimistic update
    const optimisticVotes = { ...get().votes };
    const optimisticUserVotes = { ...get().userVotes };
    
    // Calculate vote change
    const voteChange = voteType - currentUserVote;
    optimisticVotes[llmId] = (optimisticVotes[llmId] || 0) + voteChange;
    
    // Update user vote
    if (voteType === 0) {
      delete optimisticUserVotes[llmId];
    } else {
      optimisticUserVotes[llmId] = voteType;
    }
    
    set({ 
      votes: optimisticVotes,
      userVotes: optimisticUserVotes,
    });
    
    try {
      // Submit vote to Supabase
      const result = await voteManager.vote(
        llmId, 
        fingerprint, 
        voteType,
        {
          ip: window.location.hostname,
          userAgent: navigator.userAgent
        }
      );
      
      if (!result.success) {
        // Handle database rate limiting (not an error, just feedback)
        if (result.wait_seconds) {
          console.log('üìä Database rate limit triggered, showing countdown');
          
          // Revert optimistic update for rate limit
          const revertedVotes = { ...get().votes };
          revertedVotes[llmId] = (revertedVotes[llmId] || 0) - voteChange;
          
          const revertedUserVotes = { ...get().userVotes };
          if (currentUserVote === 0) {
            delete revertedUserVotes[llmId];
          } else {
            revertedUserVotes[llmId] = currentUserVote;
          }
          
          set({ 
            votes: revertedVotes,
            userVotes: revertedUserVotes,
            error: result.error
          });
          
          // Show countdown for database rate limits
          let remainingSeconds = Math.ceil(result.wait_seconds);
          const countdownTimer = setInterval(() => {
            remainingSeconds--;
            if (remainingSeconds > 0) {
              set({ error: `Rate limited. Please wait ${remainingSeconds} seconds before voting again.` });
            } else {
              set({ error: null });
              clearInterval(countdownTimer);
            }
          }, 1000);
          
          return { success: false, rateLimited: true, wait_seconds: result.wait_seconds };
        } else {
          // Actual error (not rate limit)
          console.error('Vote failed:', result.error);
          
          const revertedVotes = { ...get().votes };
          revertedVotes[llmId] = (revertedVotes[llmId] || 0) - voteChange;
          
          const revertedUserVotes = { ...get().userVotes };
          if (currentUserVote === 0) {
            delete revertedUserVotes[llmId];
          } else {
            revertedUserVotes[llmId] = currentUserVote;
          }
          
          set({ 
            votes: revertedVotes,
            userVotes: revertedUserVotes,
            error: result.error || 'Failed to submit vote'
          });
          
          setTimeout(() => set({ error: null }), 3000);
          return { success: false, error: result.error };
        }
      } else {
        console.log('‚úÖ Vote successful');
        // Real-time will handle the update
        get().updateRankings();
        return { success: true };
      }
    } catch (error) {
      console.error('‚ùå Vote error:', error);
      // Keep optimistic update but show error
      set({ error: 'Vote may not have been saved' });
      setTimeout(() => set({ error: null }), 3000);
      return { success: false, error: error.message };
    }
  },
  
  // Update rankings based on votes
  updateRankings: () => {
    const votes = get().votes;
    const rankings = Object.entries(votes)
      .map(([id, count]) => ({ 
        id, 
        count,
        name: get().getLLMById(id)?.name || id
      }))
      .sort((a, b) => b.count - a.count)
      .slice(0, 10)
      .map((item, index) => ({ ...item, rank: index + 1 }));
    
    set({ rankings });
  },
  
  // Fetch latest stats
  fetchStats: async () => {
    try {
      const stats = await voteManager.getStats();
      set({ stats, lastUpdate: new Date() });
    } catch (error) {
      console.error('Failed to fetch stats:', error);
    }
  },
  
  // Get LLM by ID
  getLLMById: (id) => {
    return get().llms.find(llm => llm.id === id);
  },
  
  // Get user's vote for an LLM
  getUserVote: (llmId) => {
    return get().userVotes[llmId] || 0;
  },
  
  // Get total votes for an LLM
  getVoteCount: (llmId) => {
    return get().votes[llmId] || 0;
  },
  
  // Check if LLM is trending (top 3)
  isTrending: (llmId) => {
    const rankings = get().rankings;
    const item = rankings.find(r => r.id === llmId);
    return item ? item.rank <= 3 : false;
  },
  
  // Get rank position for an LLM
  getRank: (llmId) => {
    const rankings = get().rankings;
    const item = rankings.find(r => r.id === llmId);
    return item ? item.rank : null;
  },
  
  // Manual sync with server
  syncWithServer: async () => {
    const fingerprint = get().fingerprint;
    if (!fingerprint) return;
    
    try {
      const syncResult = await voteManager.syncUserData(fingerprint);
      if (syncResult.success) {
        set({
          votes: syncResult.votes || get().votes,
          userVotes: syncResult.userVotes || get().userVotes,
          rankings: syncResult.rankings || get().rankings,
          stats: syncResult.stats || get().stats,
          lastUpdate: new Date(),
        });
      }
    } catch (error) {
      console.debug('Sync failed:', error);
    }
  },
  
  // Clear all data (for testing)
  clearAllStoredData: () => {
    fingerprintService.clearFingerprint();
    set({
      votes: {},
      userVotes: {},
      fingerprint: null,
      rankings: [],
      stats: {
        totalVotes: 0,
        uniqueVoters: 0,
        votesLastHour: 0,
        votesToday: 0,
        topModel: null,
        topModelVotes: 0,
      }
    });
  },
  
  // Cleanup on unmount
  cleanup: () => {
    voteManager.cleanup();
    set({ realtimeConnected: false });
  }
}));

export default useVoteStore;

// File: c:\Users\Taimoor\Documents\GitHub\llm-popularity-tracker\supabase\schema.sql
-- ============================================
-- YOUR ORIGINAL SCHEMA WITH ONLY DELETE FIX
-- ============================================
DROP TABLE IF EXISTS votes CASCADE;
DROP TABLE IF EXISTS sessions CASCADE;
DROP TABLE IF EXISTS vote_stats_aggregate CASCADE;
DROP TABLE IF EXISTS global_stats CASCADE;
DROP TABLE IF EXISTS llms CASCADE;
DROP FUNCTION IF EXISTS handle_vote CASCADE;
DROP FUNCTION IF EXISTS get_user_votes CASCADE;
DROP FUNCTION IF EXISTS update_vote_aggregates CASCADE;

-- ============================================
-- CORE TABLES (YOUR ORIGINAL)
-- ============================================

CREATE TABLE llms (
  id TEXT PRIMARY KEY,
  name TEXT NOT NULL,
  company TEXT NOT NULL,
  release_year INTEGER,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

CREATE TABLE votes (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  llm_id TEXT NOT NULL REFERENCES llms(id) ON DELETE CASCADE,
  fingerprint TEXT NOT NULL,
  vote_type INTEGER NOT NULL CHECK (vote_type IN (-1, 1)),
  ip_address TEXT,
  user_agent TEXT,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  UNIQUE(llm_id, fingerprint)
);

CREATE TABLE sessions (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  fingerprint TEXT UNIQUE NOT NULL,
  ip_address TEXT,
  user_agent TEXT,
  vote_count INTEGER DEFAULT 0,
  last_vote_at TIMESTAMP WITH TIME ZONE,
  last_activity TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- ============================================
-- AGGREGATE TABLE (YOUR ORIGINAL)
-- ============================================

CREATE TABLE vote_stats_aggregate (
  llm_id TEXT PRIMARY KEY REFERENCES llms(id) ON DELETE CASCADE,
  total_votes INTEGER DEFAULT 0,
  upvotes INTEGER DEFAULT 0,
  downvotes INTEGER DEFAULT 0,
  unique_voters INTEGER DEFAULT 0,
  last_updated TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- ============================================
-- VIEWS (YOUR ORIGINAL)
-- ============================================

CREATE VIEW global_stats AS
SELECT 
  1 as id,
  (SELECT COUNT(*) FROM votes) as total_votes,
  COALESCE(SUM(unique_voters), 0) as unique_voters,
  (SELECT COUNT(*) FROM votes WHERE created_at > NOW() - INTERVAL '1 hour') as votes_last_hour,
  (SELECT COUNT(*) FROM votes WHERE created_at > CURRENT_DATE) as votes_today,
  (SELECT llm_id FROM vote_stats_aggregate ORDER BY total_votes DESC LIMIT 1) as top_model,
  (SELECT MAX(total_votes) FROM vote_stats_aggregate) as top_model_votes,
  NOW() as last_updated
FROM vote_stats_aggregate;

CREATE VIEW vote_counts AS
SELECT 
  l.id as llm_id,
  l.name,
  l.company,
  COALESCE(v.total_votes, 0) as total_votes,
  COALESCE(v.upvotes, 0) as upvotes,
  COALESCE(v.downvotes, 0) as downvotes,
  COALESCE(v.unique_voters, 0) as unique_voters
FROM llms l
LEFT JOIN vote_stats_aggregate v ON l.id = v.llm_id
ORDER BY total_votes DESC;

-- ============================================
-- YOUR ORIGINAL HANDLE_VOTE FUNCTION (WORKS!)
-- ============================================

CREATE OR REPLACE FUNCTION handle_vote(
  p_llm_id TEXT,
  p_fingerprint TEXT,
  p_vote_type INTEGER,
  p_ip_address TEXT DEFAULT NULL,
  p_user_agent TEXT DEFAULT NULL
) RETURNS JSON AS $$
DECLARE
  v_previous_vote INTEGER;
  v_recent_votes INTEGER;
  v_last_vote_time TIMESTAMP;
  v_result JSON;
BEGIN
  -- Check rate limiting (5 votes per minute max)
  SELECT COUNT(*), MIN(created_at) INTO v_recent_votes, v_last_vote_time
  FROM votes 
  WHERE fingerprint = p_fingerprint 
    AND created_at > NOW() - INTERVAL '1 minute';
  
  IF v_recent_votes >= 5 THEN
    RETURN json_build_object(
      'success', false,
      'message', 'Rate limit exceeded. Please wait before voting again.',
      'wait_seconds', GREATEST(0, 60 - EXTRACT(EPOCH FROM (NOW() - v_last_vote_time))::INTEGER)
    );
  END IF;
  
  -- Get previous vote if exists
  SELECT vote_type INTO v_previous_vote
  FROM votes
  WHERE llm_id = p_llm_id AND fingerprint = p_fingerprint
  FOR UPDATE;
  
  -- If same vote, do nothing
  IF v_previous_vote = p_vote_type THEN
    RETURN json_build_object(
      'success', false,
      'message', 'Vote unchanged',
      'previous_vote', v_previous_vote
    );
  END IF;
  
  -- Handle vote deletion (vote_type = 0)
  IF p_vote_type = 0 THEN
    DELETE FROM votes 
    WHERE llm_id = p_llm_id AND fingerprint = p_fingerprint;
  ELSE
    -- Insert or update vote
    INSERT INTO votes (llm_id, fingerprint, vote_type, ip_address, user_agent)
    VALUES (p_llm_id, p_fingerprint, p_vote_type, p_ip_address, p_user_agent)
    ON CONFLICT (llm_id, fingerprint)
    DO UPDATE SET 
      vote_type = EXCLUDED.vote_type,
      updated_at = NOW();
  END IF;
  
  -- Update session activity with last vote time
  INSERT INTO sessions (fingerprint, ip_address, user_agent, vote_count, last_vote_at)
  VALUES (p_fingerprint, p_ip_address, p_user_agent, 1, NOW())
  ON CONFLICT (fingerprint)
  DO UPDATE SET 
    vote_count = sessions.vote_count + 1,
    last_vote_at = NOW(),
    last_activity = NOW();
  
  -- Update aggregate for this specific LLM
  WITH vote_summary AS (
    SELECT 
      COALESCE(SUM(vote_type), 0) as total,
      COUNT(CASE WHEN vote_type = 1 THEN 1 END) as ups,
      COUNT(CASE WHEN vote_type = -1 THEN 1 END) as downs,
      COUNT(DISTINCT fingerprint) as voters
    FROM votes
    WHERE llm_id = p_llm_id
  )
  INSERT INTO vote_stats_aggregate (llm_id, total_votes, upvotes, downvotes, unique_voters)
  SELECT p_llm_id, total, ups, downs, voters FROM vote_summary
  ON CONFLICT (llm_id) DO UPDATE SET
    total_votes = EXCLUDED.total_votes,
    upvotes = EXCLUDED.upvotes,
    downvotes = EXCLUDED.downvotes,
    unique_voters = EXCLUDED.unique_voters,
    last_updated = NOW();
  
  -- Return success with vote counts
  SELECT json_build_object(
    'success', true,
    'previous_vote', v_previous_vote,
    'new_vote', p_vote_type,
    'vote_count', (SELECT total_votes FROM vote_stats_aggregate WHERE llm_id = p_llm_id)
  ) INTO v_result;
  
  RETURN v_result;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER; -- ADD SECURITY DEFINER!

-- ============================================
-- YOUR OTHER FUNCTIONS
-- ============================================

CREATE OR REPLACE FUNCTION get_user_votes(p_fingerprint TEXT)
RETURNS JSON AS $$
BEGIN
  RETURN COALESCE(
    (SELECT json_object_agg(llm_id, vote_type)
     FROM votes
     WHERE fingerprint = p_fingerprint),
    '{}'::json
  );
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION update_all_aggregates() 
RETURNS void AS $$
BEGIN
  INSERT INTO vote_stats_aggregate (llm_id, total_votes, upvotes, downvotes, unique_voters)
  SELECT 
    l.id,
    COALESCE(SUM(v.vote_type), 0),
    COALESCE(COUNT(CASE WHEN v.vote_type = 1 THEN 1 END), 0),
    COALESCE(COUNT(CASE WHEN v.vote_type = -1 THEN 1 END), 0),
    COALESCE(COUNT(DISTINCT v.fingerprint), 0)
  FROM llms l
  LEFT JOIN votes v ON l.id = v.llm_id
  GROUP BY l.id
  ON CONFLICT (llm_id) DO UPDATE SET
    total_votes = EXCLUDED.total_votes,
    upvotes = EXCLUDED.upvotes,
    downvotes = EXCLUDED.downvotes,
    unique_voters = EXCLUDED.unique_voters,
    last_updated = NOW();
END;
$$ LANGUAGE plpgsql;

-- ============================================
-- ROW LEVEL SECURITY (FIXED!)
-- ============================================

ALTER TABLE llms ENABLE ROW LEVEL SECURITY;
ALTER TABLE votes ENABLE ROW LEVEL SECURITY;
ALTER TABLE sessions ENABLE ROW LEVEL SECURITY;
ALTER TABLE vote_stats_aggregate ENABLE ROW LEVEL SECURITY;

-- LLMs policies
CREATE POLICY "Public can read LLMs" ON llms
  FOR SELECT USING (true);

-- Votes policies (FIXED FOR DELETE!)
CREATE POLICY "Public can read votes" ON votes
  FOR SELECT USING (true);

CREATE POLICY "Public can insert votes" ON votes
  FOR INSERT WITH CHECK (true);

CREATE POLICY "Public can update votes" ON votes
  FOR UPDATE USING (true);

-- THIS IS THE FIX: Allow deletion
CREATE POLICY "Public can delete votes" ON votes
  FOR DELETE USING (true);

-- Sessions policies
CREATE POLICY "Public can read sessions" ON sessions
  FOR SELECT USING (true);

CREATE POLICY "Public can manage sessions" ON sessions
  FOR ALL USING (true);

-- Aggregate tables policies
CREATE POLICY "Public can read aggregates" ON vote_stats_aggregate
  FOR SELECT USING (true);

-- ============================================
-- INDEXES (YOUR ORIGINAL)
-- ============================================

CREATE INDEX idx_votes_llm_fingerprint ON votes(llm_id, fingerprint);
CREATE INDEX idx_votes_fingerprint_created ON votes(fingerprint, created_at DESC);
CREATE INDEX idx_votes_created_at ON votes(created_at DESC);
CREATE INDEX idx_sessions_fingerprint ON sessions(fingerprint);
CREATE INDEX idx_sessions_last_vote ON sessions(last_vote_at DESC);
CREATE INDEX idx_vote_stats_total_votes ON vote_stats_aggregate(total_votes DESC);

-- ============================================
-- REALTIME (YOUR ORIGINAL)
-- ============================================

ALTER PUBLICATION supabase_realtime ADD TABLE vote_stats_aggregate;

-- ============================================
-- INSERT LLM DATA
-- ============================================

INSERT INTO llms (id, name, company, release_year) VALUES
('gpt-5', 'GPT-5', 'OpenAI', 2025),
('claude-4-sonnet', 'Claude 4 Sonnet', 'Anthropic', 2025),
('claude-4-opus', 'Claude 4 Opus', 'Anthropic', 2025),
('gemini-2-5-pro', 'Gemini 2.5 Pro', 'Google', 2025),
('deepseek-r1', 'DeepSeek R1', 'DeepSeek', 2025),
('gpt-4o', 'GPT-4o', 'OpenAI', 2024),
('o3', 'OpenAI o3', 'OpenAI', 2025),
('o4-mini', 'OpenAI o4-mini', 'OpenAI', 2025),
('llama-4-maverick', 'Llama 4 Maverick', 'Meta', 2025),
('llama-4-scout', 'Llama 4 Scout', 'Meta', 2025),
('grok-3', 'Grok 3', 'xAI', 2025),
('gemini-2-5-flash', 'Gemini 2.5 Flash', 'Google', 2025),
('qwen-2-5', 'Qwen 2.5', 'Alibaba', 2024),
('mistral-large-2', 'Mistral Large 2', 'Mistral AI', 2024),
('command-r-plus', 'Command R+', 'Cohere', 2024),
('gpt-4-1', 'GPT-4.1', 'OpenAI', 2025),
('deepseek-v3', 'DeepSeek V3', 'DeepSeek', 2024),
('yi-lightning', 'Yi Lightning', '01.AI', 2024),
('phi-4', 'Phi-4', 'Microsoft', 2025),
('ernie-4-turbo', 'ERNIE 4.0 Turbo', 'Baidu', 2024);

-- Initialize aggregates
INSERT INTO vote_stats_aggregate (llm_id, total_votes, upvotes, downvotes, unique_voters)
SELECT id, 0, 0, 0, 0 FROM llms;

-- ============================================
-- CRON JOB SETUP
-- ============================================

-- Enable pg_cron extension if not already enabled
CREATE EXTENSION IF NOT EXISTS pg_cron;

-- Schedule the aggregate update function to run every 5 seconds
SELECT cron.schedule(
  'update-vote-aggregates',
  '*/10 * * * * *',
  'SELECT update_all_aggregates();'
);

